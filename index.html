<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R Workshop</title>
    <meta charset="utf-8" />
    <meta name="author" content="Felix lorenz" />
    <script src="index_files/header-attrs/header-attrs.js"></script>
    <link href="index_files/remark-css/default.css" rel="stylesheet" />
    <link href="index_files/xaringanExtra-banner/banner.css" rel="stylesheet" />
    <script src="index_files/xaringanExtra-banner/banner.js"></script>
    <link href="index_files/panelset/panelset.css" rel="stylesheet" />
    <script src="index_files/panelset/panelset.js"></script>
    <link href="index_files/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="index_files/countdown/countdown.css" rel="stylesheet" />
    <script src="index_files/countdown/countdown.js"></script>
    <link rel="stylesheet" href="img/styles_x.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R Workshop
]
.author[
### Felix lorenz
]
.date[
### 12. Dezember 2022
]

---

<div>
<style type="text/css">.xaringan-extra-logo {
width: 110px;
height: 128px;
z-index: 0;
background-image: url(./img/tg.jpg);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:1em;right:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

<script>document.addEventListener('DOMContentLoaded',function(){new xeBanner(JSON.parse('{"left":"<h6>Staatskanzlei<\/h6><h7>Dienststelle für Statistik<\/h7>","exclude":["title-slide"],"position":"top"}'))})</script>
<script>document.addEventListener('DOMContentLoaded',function(){new xeBanner(JSON.parse('{"left":"12. Dezember 2022","center":"© Staatskanzlei","exclude":["title-slide"],"position":"bottom"}'))})</script>







































----
## Ziele des Workshops


1. Richtiges Mindset schaffen, um Programmieren zu lernen

2. Möglichst breiten Blick auf die Möglichkeiten von R schaffen, um Grundstein für selbstständiges Lernen zu bilden.

3. Beispiele aus der Praxis in der Dienststelle für Statistik zum besseren Verständnis


---
----
## R und RStudio

.pull-left[
**R**
- R ist eine freie (open-source) Programmiersprache, erschienen in 1993
- R ist eine Arbeitsumgebung für statistische Analysen und Grafiken (und vieles mehr)
- R kann mit *packages* erweitert werden
]
--
.pull-right[

**RStudio**

- RStudio ist eine grafische Benutzeroberfläche, welche auch integrierte Entwicklunsumgebung (i.e. IDE - integrated development environment) genannt wird

]

---
----
## Die R und tidyverse-Bibel

&lt;div class="figure"&gt;
&lt;img src="https://pictures.abebooks.com/isbn/9781491910399-de.jpg" alt="https://pictures.abebooks.com/isbn/9781491910399-de.jpg" width="30%" /&gt;
&lt;p class="caption"&gt;https://pictures.abebooks.com/isbn/9781491910399-de.jpg&lt;/p&gt;
&lt;/div&gt;

Das Buch ist kostenlos [hier](https://r4ds.had.co.nz/index.html) zu finden und ist ideal für Einsteiger.





---
----
## Aufbau RStudio
&lt;img src="./img/Rstudio.jpg" width="100%" /&gt;


---
----
## R Projects

- Daten, Scripts etc. werden in einem Ordner gebündelt
- erleichtert die Strukturierung und erhöht die Übersichtlichkeit

**Derzeitige Ordnung im Y widerspricht dieser Logik**


&lt;img src="./img/03_projects.PNG" width="60%" /&gt;
---
----
## R Projects

In der Regel folgen Projekte dem untenstehenden Aufbau. Dieser ist dem Aufbau eines Packages nachempfunden. Dies ist jedoch kein Muss und kann variiert werden.


```r
# Project
- data
  -&gt; dataset.csv
- R
  -&gt; data_preparation.R
- output
  -&gt; output.xlsx
- www
  -&gt; image.png
```

---
----
## Hands On: R Projects und initiale Einstellungen

- Unnötiges Speichern/Laden von Daten ausstellen

- Global Options kennenlernen

- Projekte erstellen

---
----

## Funktionen, Objekte und Packages



&gt; **In R ist alles ein Objekt – auch Funktionen sind spezielle Objekte.**

R speichert sowohl Daten als auch Funktionen als Objekte. So können alle Elemente einheitlich behandelt und flexibel genutzt werden.




---
----

## Datenstrukturen

R besitzt verschiedene Basisobjekte, die ihr bereits im *DataCamp* Kurs kennengelernt habt. Die meistgenutzten sind:

.panelset[
.panel[.panel-name[Variablen]
- grundlegenstes und kleinstes R Objekt
- kann `numeric`, `character` oder `logical` sein

```r
x &lt;- 10
y  = "Das ist ein String"
x
```

```
## [1] 10
```

```r
y
```

```
## [1] "Das ist ein String"
```
]
.panel[.panel-name[Vektoren]
- eindimensionales Objekt. Alle Elemente müssen den gleichen Datentyp haben.
- am häufigsten verwendet werden `numeric`, `character` oder `logical`

```r
vec_num &lt;- c(1,5,2)
vec_char &lt;- c("one","five",NA)
var_log &lt;- c(FALSE,TRUE,TRUE)
vec_num
```

```
## [1] 1 5 2
```

```r
vec_char
```

```
## [1] "one"  "five" NA
```
]
.panel[.panel-name[Data Frames]
- vergleichbar mit klassischer Tabelle (alle Spalten müssen gleich lang sein)
- einzelne Spalten sind im Prinzip Vektoren und besitzen die gleichen Eigenschaften

```r
df &lt;- data.frame(col_1 = c(1,5,2),col_2 = vec_char)
df
```

```
##   col_1 col_2
## 1     1   one
## 2     5  five
## 3     2  &lt;NA&gt;
```
]

.panel[.panel-name[Listen]
- Boxen die unterschiedlichste Objekte enthalten können
- in einer Liste kann prinzipiell alles gespeichert werden

```r
temp_list &lt;- list(x,y,vec_num, vec_char,df)
temp_list[[5]]
```

```
##   col_1 col_2
## 1     1   one
## 2     5  five
## 3     2  &lt;NA&gt;
```
]

]



---
----
## Funktionen
- Funktionen sind wichtige Bestandteile im Arbeiten mit R. Einzelne Tasks können mit einer Funktion zusammengefasst und reproduzierbar gemacht werden


.panelset[
.panel[.panel-name[built-in]

R besitzt viele "built-in" Funktionen, wie z. B. mathematischen Grundlagen (`mean()`,`sum()`,`sqrt()`, etc.)

```r
values &lt;- c(3,9,6,8)
mean(values)
```

```
## [1] 6.5
```
]
.panel[.panel-name[Aus package]

Einzelne Funktionen aus packages können mit voransgestelltem `packagename::` aufgerufen werden. 

Die `library` Funktion lädt alle Funktionen des Packages. Der vorangestellte package Name kann dann weggeleassen werden.

```r
library(dplyr)
```

```r
dplyr::dense_rank(values)
```

```
## [1] 1 4 2 3
```
]
.panel[.panel-name[Eigene Funktion]

Funktionen können auch vom User selbst ersetellt werden


```r
greetings &lt;- function(name){
  result &lt;- paste0("Hello ",name,". Nice to meet you.")
  print(result)
}
```

```r
greetings(name="Joe")
```


]
.panel[.panel-name[Ergebnis]

```
## [1] "Hello Joe. Nice to meet you."
```
]
]
---
----

## Packages

- Erweiterungen, die reproduzierbare Funktionen enthalten und kostenfrei genutzt werden können
- Packages können direkt von [CRAN (Comrehensive R Archive Network)](https://cran.r-project.org/) installiert werden
- Packages können auch von GitHub, GitLab o.ä. installiert werden
- Jede/r kann Packages entwickeln 


```r
# CRAN
install.packages("package_name")
install.packages("dplyr")

# GITHUB
devtools::install_github("username/package_name")
devtools::install_github("ogdtg/tgAPI")

# GITLAB
devtools::install_gitlab("username/packagename")

# uvm...
```
---

























----
## "Programmierweisheiten"

--

**1. Jedes Problem hatte irgendjemand anders schon einmal...**

--

**2. "Richtiges" Googlen ist die halbe Miete beim Programmieren.**

--

**3. Man kann oft mehr automatisieren, als man im ersten Moment denkt.**

--

**4. Automatisierung bring *immer* einen Mehrwert.**

--

**5. Viele Wege führen nach Rom.**

---
----
## Jedes Problem hatte irgendjemand anders schon einmal...

...die Lösung ist daher meistens auch irgendwo zu finden.

- Code übernehmen und reproduzieren, anstatt das Rad jedes Mal neu erfinden

- [Stack Overflow](https://stackoverflow.com/) hilft (fast) immer. (*"Every data scientist has a tab open to Stack Overflow"*)

- Unzählige weitere Hilfeseiten z.B. [Rbloggers](https://www.r-bloggers.com/), [Geeks for Geeks](https://www.geeksforgeeks.org/r-programming-language-introduction/), etc.

&lt;br&gt;
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://upload.wikimedia.org/wikipedia/commons/0/02/Stack_Overflow_logo.svg" alt="https://upload.wikimedia.org/wikipedia/commons/0/02/Stack_Overflow_logo.svg" width="40%" /&gt;
&lt;p class="caption"&gt;https://upload.wikimedia.org/wikipedia/commons/0/02/Stack_Overflow_logo.svg&lt;/p&gt;
&lt;/div&gt;


---
----
## "Richtiges" Googlen ist die halbe Miete

- Programmieren ist ein englischsprachiges Feld &amp;#10140; auf Englisch googlen bringt die besten Ergebnisse

- Bei Fehlermeldungen kann als erster Schritt einfach der Text der Meldung gegooglet werden &amp;#10140; bringt meistens schon ersten Anhaltspunkt

---
----
## Man kann oft mehr automatisieren als man im ersten Moment denkt
&lt;br&gt;
- Prozesse als Ganzes betrachten! Kann ich vielleicht noch mehr automatisieren, als diesen einen spezifischen Prozessschritt?

- Kann ich meine Arbeit skalieren und für andere Prozesse nutzen?

- Wie kann ich meinen Code so generisch wie möglich schreiben?

---
----
## Automatisierung bring immer einen Mehrwert

--

- Automatisierung spart oft Zeit

--

- Automatisierung reduziert meistens die Fehleranfälligkeit

--

- Automatisierung bringt **immer** einen Lerneffekt

--

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://marcgg.com/assets/blog/automation-win.png" alt="https://marcgg.com/assets/blog/automation-win.png" width="55%" /&gt;
&lt;p class="caption"&gt;https://marcgg.com/assets/blog/automation-win.png&lt;/p&gt;
&lt;/div&gt;


---
----
## Viele Wege führen nach Rom

- Es gibt niemals "die eine Lösung"

- Probleme können auf die unterschiedlichste Art, mit den unterschiedlichsten Funktionen und den unterschiedlichsten Packages gelöst werden
&lt;br&gt;
&lt;br&gt;
&lt;h2 align="center"&gt;&lt;i&gt;"Der beste Code ist der, der verlässlich funktioniert" &lt;/i&gt;&lt;/p&gt;

---
----
## Programmieren lernt man nur durch Anwendung!

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/how_much_I_think_I_know_about_R.PNG" alt="https://tidyverse.tidyverse.org/logo.png" width="598" /&gt;
&lt;p class="caption"&gt;https://tidyverse.tidyverse.org/logo.png&lt;/p&gt;
&lt;/div&gt;
---
























----
## Das tidyverse 
.pull-left[
tidyverse ist eine Sammlung von zusammenhängenden R-Paketen. Sie basiert auf der Idee von tidy Data, wo jede Spalte eine Variable, jede Zeile eine Beobachtung und jede Zelle einen einzelnen Wert darstellt.

Das tidyverse umfasst Pakete für die Datenmanipulation, Visualisierung und Modellierung. Alle Packages basieren auf einer konsistenten "Grammatik".

]
.pull-right[
&lt;div class="figure"&gt;
&lt;img src="https://tidyverse.tidyverse.org/logo.png" alt="https://tidyverse.tidyverse.org/logo.png" style =top: 0; right: 0; display: block; margin-left: auto; /&gt;
&lt;p class="caption"&gt;https://tidyverse.tidyverse.org/logo.png&lt;/p&gt;
&lt;/div&gt;
]

---
----
## Das tidyverse
&lt;figure class="logo-fig logo-title1"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title4"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title5"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title6"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title7"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title8"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title9"&gt;
  &lt;a href='https://forcats.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://forcats.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


&lt;figure class="logo-fig logo-title10"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;


---
























----
## Daten einlesen


&lt;figure class="logo-fig logo-title1"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title4"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title5"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title6"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title7"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title8"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title9"&gt;
  &lt;a href='https://forcats.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://forcats.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


&lt;figure class="logo-fig logo-title10"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

---
----
## Daten einlesen

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


R kann prinzipiell jede Form von Daten einlesen:

- für Standard Formate wie csv oder txt wird das `readr` package benutzt.

- für Dateitypen aus anderen Statistik Tools wie SAS, SPSS oder STATA kann `haven` benutzt werden.

- Excel Files können mit dem `readxl` package eingelesen werden

Generell gibt es sehr viele verschiedene Einlesefunktionen und -packages, die alle das gleiche Ergebnis liefern.

Sie unterscheiden sich jedoch in ihrer Perfomance.

---
----
## Daten einlesen


&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[CSV]

```r
library(readr)
# Comma separated
df_comma &lt;- read_csv("path/to/comma_separated.csv")

# Semicolon separated
df_semicolon &lt;- read_csv2("path/to/semicolon_separated.csv")

# Tab separated
df_tab &lt;- read_tsv("path/to/tab_separated.csv")
```
]
.panel[.panel-name[Excel]

```r
library(readxl)
df_excel &lt;- read_excel("path/to/excel_file.xlsx")
```
]
.panel[.panel-name[SAS]

```r
library(haven)
df_sas &lt;- read_sas("path/to/sas_file.sas7bdat")
```
]
.panel[.panel-name[fwf]
- *"fixed width file"* wie teilweise vom BFS erhalten

```r
library(readr)
df_fwf &lt;- read_fwf("path/to/fwf_data.txt",
                 fwf_positions(start=vec_start_col,
                               end=vec_end_col,
                               col_names = vec_names_col)
                 )
```
]
.panel[.panel-name[rds/rda]
- `rds` und `rda` sind die R-internen Datenfromate
- sie sind optimiert für R, können schnell geladen werden und sind speichereffizient

```r
# speichern
saveRDS(dataset, "data.rds")

# laden
dataset &lt;- readRDS("data.rds")
```
]
]



---
----
## Hands-On: Daten einlesen (Zeit: 10 Minuten)

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;ol type="a"&gt;
  &lt;li&gt;&lt;b&gt;EXCEL&lt;/b&gt;&lt;br&gt;
  Lies die Datei &lt;b&gt;bevölkerung.xlsx&lt;/b&gt; als data.frame ein.&lt;br&gt;
  Nenne den data.frame "bev".&lt;br&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;b&gt;CSV&lt;/b&gt;&lt;br&gt;
  Lies die Datei &lt;b&gt;bevölkerung.csv&lt;/b&gt; als data.frame ein.&lt;br&gt;
  Nenne den data.frame "bev_csv"&lt;br&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;b&gt;SAS&lt;/b&gt;&lt;br&gt;
  Lies die Datei &lt;b&gt;bevnatgeb2021.sas7bdat&lt;/b&gt; als data.frame ein.&lt;br&gt;
  Nenne den data.frame "bevnat".&lt;br&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;b&gt;EXCEL (Bonus)&lt;/b&gt;&lt;br&gt;
  Lies das Tabellenblatt &lt;b&gt;"altersklassen"&lt;/b&gt; aus der Datei &lt;b&gt;bevölkerung.xlsx&lt;/b&gt; als data.frame ein.&lt;br&gt;
  Nenne den data.frame "alter" und speichere ihn als &lt;b&gt;alter.csv&lt;/b&gt; in deinem Output Ordner.&lt;br&gt;
  &lt;/li&gt;
&lt;/ol&gt;

Benutze jeweils die `head()` Funktion um **die ersten 3 Zeilen** des Datensatzes anzeigen zu lassen. 

<div class="countdown" id="timer_eb743e62" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
----
## Hands-On: Daten einlesen (Zeit: 10 Minuten)

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[Lösung a)]



```r
library(readr)
df &lt;- read_csv("Data/Geburten.csv")
head(df,3)
```
]

.panel[.panel-name[Lösung b)]



```r
library(haven)
df &lt;- read_sas("bevnatgeb2020.sas7bdat")
head(df,3)
```
]

.panel[.panel-name[Lösung c)]



```r
library(readxl)
df &lt;- read_excel("Daten/test.xlsx")
head(df,3)
```
]
.panel[.panel-name[Lösung d)]


```r
df &lt;- read_excel("Daten/test.xlsx",sheet="Bonus")
head(df,3)
write_csv(df,"Felix/Output/alter.csv", na ="")
```
]
]

---
----
## Daten einlesen: Good to know 

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-fig-small3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;p style="margin-top:70px;"&gt;&lt;p/&gt;
Sollen mehrere Files aus einem Ordner eingelesen werden, kann die `list.files()` Funktion verwendet werden. Mit dieser Funktion werden alle Files mit einer spezifischen Endung innerhalb eines Ordners aufgelistet. Diese können dann mit einem `for`-Loop oder einer der `apply` Funktionen schnell eingelesen werden.

```r
# Listet alle CSV Files im Ordner
list.files(path = "path/to/directory", pattern = "*.csv")
```

Bei grossen Files kann es manchmal zu Problemen beim Einlesen kommen, aufgrund der internen Logik von R.
&lt;br&gt;
Im hier verlinkten [Tutorial](https://inbo.github.io/tutorials/tutorials/r_large_data_files_handling/) werden entsprechende Lösungsansätze aufgezeigt.
---























----
## Data Manipulation

&lt;figure class="logo-fig logo-title1"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title4"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title5"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title6"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title7"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title8"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title9"&gt;
  &lt;a href='https://forcats.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://forcats.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


&lt;figure class="logo-fig logo-title10"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


---
----
## magrittr:: %&gt;%

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit dem `magrittr` package und dem darin enthaltenen Pipeline Operator `%&gt;%` wird euer Code viel einfacher lesbar.
- Der Code wird durch die Nutzung der Pipe weniger verschachtelt und so einfacher zu debuggen.


.panelset[
.panel[.panel-name[Ohne Pipe]
Innerste Klammer wird zuerst usgeführt

```r
h(g(f(df)))
```
]
.panel[.panel-name[Mit Pipe]
Code wird nacheinander ausgeführt (f() dann g() dann h())

```r
df %&gt;% 
  f() %&gt;% 
  g() %&gt;% 
  h()
```
]
.panel[.panel-name[Ohne Platzhalter]

```r
langer_variablenname %&gt;%  f(y, z = langer_variablenname)
```
]
.panel[.panel-name[Mit Platzhalter]
Innerhalb der Pipeline kann anstelle der Variable, auf welche die Operationen angewendet werden auch der `.` als Platzhalter verwendet werden.

```r
langer_variablenname %&gt;%  f(y, z = .)
```
]
]

---
----
## Hands-On: Piping mit magrittr:: %&gt;%

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

```r
num_vec &lt;- c(5,4,6,1,4)

round(sqrt(sum(num_vec)),1)
```
`num_vec` soll aufsummiert und anschliessend soll die Wurzel aus der Summe gezogen werden. 
Das Ergebnis soll auf eine Nachkommastelle gerundet werden
Die oben stehende Codezeile führt diese Operationen aus. 

&lt;ol type="a"&gt;
  &lt;li&gt;
  Verwende den &lt;b&gt;%&gt;%&lt;/b&gt; Operator um die oben stehende Codezeile in eine Pipe im Stile von dplyr umzuwandeln&lt;br&gt;
  Wandle die Zeile in EINE Pipe um OHNE Zwischenergebnisse zu speichern. Verwende den Namen des Vektors nur EINMAL.
  &lt;/li&gt;
&lt;/ol&gt;

<div class="countdown" id="timer_fa425a05" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---

























----
## Recap: Tidy Data

- Jede Spalte eine Variable
- Jede Zeile eine Beobachtung
- Jede Zelle ein einzelner Wert

**Vorteile von Tidy Data**

1. Konsistente Struktur &amp;#10140; es ist leichter, Tools auf verschiedene Datensätze anzuwenden, wenn diese der gleichen Struktur folgen

2. Tidy Data entspricht der inneren Arbeitslogik von R &amp;#10140; Funktionen lassen sich leichter auf Tidy Data anwenden

**Merke:** Tidy Data ist zwar erstrebenswert, aber sollte kein Selbstzweck sein.

---
----

## Recap: Tidy Data

**Beispiel:** COVID Fallzahlen


```
## # A tibble: 4 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;     
## 1 2022-12-10 TG     140474    723 723/140474
## 2 2022-12-11 TG     140484    723 723/140484
## 3 2022-12-10 BS     102405    372 372/102405
## 4 2022-12-11 BS     102405    372 372/102405
```

--

&lt;p class="check-no"&gt;&amp;#10060;&lt;/p&gt;

---
----

## Recap: Tidy Data

**Beispiel:** COVID Fallzahlen


```
## # A tibble: 8 × 4
##   date       kanton indicator  value
##   &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     cases     140474
## 2 2022-12-10 TG     deaths       723
## 3 2022-12-11 TG     cases     140484
## 4 2022-12-11 TG     deaths       723
## 5 2022-12-10 BS     cases     102405
## 6 2022-12-10 BS     deaths       372
## 7 2022-12-11 BS     cases     102405
## 8 2022-12-11 BS     deaths       372
```

--

&lt;p class="check-no"&gt;&amp;#10060;&lt;/p&gt;
---
----

## Recap: Tidy Data

**Beispiel:** COVID Fallzahlen


```
## # A tibble: 4 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
## 2 2022-12-11 TG     140484    723    0.00515
## 3 2022-12-10 BS     102405    372    0.00363
## 4 2022-12-11 BS     102405    372    0.00363
```

--

&lt;p class="check-yes"&gt;&amp;#10003;&lt;/p&gt;
---
----

## Recap: Tidy Data

**Beispiel:** COVID Fallzahlen


```
## # A tibble: 2 × 3
##   kanton `2022-12-10` `2022-12-11`
##   &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;
## 1 TG           140474       140484
## 2 BS           102405       102405
```

--

&lt;p class="check-no"&gt;&amp;#10060;&lt;/p&gt;
---

























----
## tidyr

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Das `tidyr` package dient dazu Daten ins Tidy Format zu bringen und liefert dazu mehrere nützliche Funktionen

Für detailliertere Informationen findet sich [hier](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf) ein empfehlenswertes Cheatsheet

**Die drei meist genutzten Funktionen sind:**
- `pivot_longer`: fasst mehrere Spalten zusammen und "verlängert" den Datensatz
- `pivot_wider`: fasst Zeilen zusammen und "verbreitert" den Datensatz
- `separate`: teilt eine Spalte in mehrere Spalten auf (Gegenstück ist `unite`)

---
----
## tidyr

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[Ausgangsdaten]

```
## # A tibble: 4 × 4
##   date       kanton  cases deaths
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723
## 2 2022-12-11 TG     140484    723
## 3 2022-12-10 BS     102405    372
## 4 2022-12-11 BS     102405    372
```
]
.panel[.panel-name[pivot_longer]
Fasst mehrere Spalten zusammen und "verlängert" den Datensatz

```r
df_tidy_m %&gt;% 
  tidyr::pivot_longer(cols = c("cases","deaths"), names_to = c("indicator"))
```

```
## # A tibble: 8 × 4
##   date       kanton indicator  value
##   &lt;date&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     cases     140474
## 2 2022-12-10 TG     deaths       723
## 3 2022-12-11 TG     cases     140484
## 4 2022-12-11 TG     deaths       723
## 5 2022-12-10 BS     cases     102405
## 6 2022-12-10 BS     deaths       372
## 7 2022-12-11 BS     cases     102405
## 8 2022-12-11 BS     deaths       372
```
]
.panel[.panel-name[pivot_wider]
"Verbreitert" den Datensatz

```r
df_tidy_m %&gt;% 
  tidyr::pivot_wider(names_from = "kanton", values_from = c("cases","deaths"))
```

```
## # A tibble: 2 × 5
##   date       cases_TG cases_BS deaths_TG deaths_BS
##   &lt;date&gt;        &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1 2022-12-10   140474   102405       723       372
## 2 2022-12-11   140484   102405       723       372
```
]
.panel[.panel-name[separate]
Spalten können mit `separate` in mehrere Spalten aufgeteilt werden.

```r
df_tidy_m %&gt;% 
  tidyr::separate(col="date",sep = "-", into = c("year","month","day"))
```

```
## # A tibble: 4 × 6
##   year  month day   kanton  cases deaths
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 2022  12    10    TG     140474    723
## 2 2022  12    11    TG     140484    723
## 3 2022  12    10    BS     102405    372
## 4 2022  12    11    BS     102405    372
```
]
]

---
----
## Hands-On: Tidy Data mit tidyr

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


```r
library(tidyr)

abstimmungen &lt;- readRDS("Daten/Abstimmungen.rds")
```

1. Bringe die Abstimmungsdaten in eine sinnvolle Form im Sinne von Tidy Data (Wide format)&lt;br&gt;
  Alle Werte in der "Ergebnis" Spalte sollen eine einzelne Spalte sein.&lt;br&gt;
  Ihnen soll jeweils der entsprechende Wert aus der Spalte "Volksabstimmungen (Ergebnisse Ebene Kanton seit 1866)" untergeordnet werden

2. Bringe die Daten wieder in die Ursprungsform (long format)&lt;br&gt;
  Speichere das Ergebnis unter "abstimmungen_not_tidy" 
  
<div class="countdown" id="timer_8cff0f24" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---


























----
## dplyr::select()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit der `select` können die gewünschten Variablen aus dem Datensatz ausgewählt und/oder entfernt werden.

.panelset[
.panel[.panel-name[Ausgangsdaten]

```r
df_tidy
```

```
## # A tibble: 4 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
## 2 2022-12-11 TG     140484    723    0.00515
## 3 2022-12-10 BS     102405    372    0.00363
## 4 2022-12-11 BS     102405    372    0.00363
```
]
.panel[.panel-name[Bsp. 1]
- Variablennamen können direkt an die `select` Funktion übergeben werden.
- Genauso können Variablen auch als Vektor mit `c()` angegeben werden.


```r
df_tidy %&gt;% 
  select(date,cases)
```

```
## # A tibble: 4 × 2
##   date        cases
##   &lt;date&gt;      &lt;dbl&gt;
## 1 2022-12-10 140474
## 2 2022-12-11 140484
## 3 2022-12-10 102405
## 4 2022-12-11 102405
```
]
.panel[.panel-name[Bsp. 2]
Variablen können auch als *range* ausgewählt werden

```r
df_tidy %&gt;% 
  select(date:cases)
```

```
## # A tibble: 4 × 3
##   date       kanton  cases
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;
## 1 2022-12-10 TG     140474
## 2 2022-12-11 TG     140484
## 3 2022-12-10 BS     102405
## 4 2022-12-11 BS     102405
```
]
.panel[.panel-name[Bsp. 3]
Auswahl per Spaltenindex ist ebenfalls möglich

```r
df_tidy %&gt;% 
  select(1,3:5)
```

```
## # A tibble: 4 × 4
##   date        cases deaths death_rate
##   &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 140474    723    0.00515
## 2 2022-12-11 140484    723    0.00515
## 3 2022-12-10 102405    372    0.00363
## 4 2022-12-11 102405    372    0.00363
```
]
.panel[.panel-name[Bsp. 4]
Mit vorangestelltem minus (`-`) können Variablen entfernt werden

```r
df_tidy %&gt;% 
  select(-c(date:cases))
```

```
## # A tibble: 4 × 2
##   deaths death_rate
##    &lt;dbl&gt;      &lt;dbl&gt;
## 1    723    0.00515
## 2    723    0.00515
## 3    372    0.00363
## 4    372    0.00363
```
]
.panel[.panel-name[Bsp. 5]
`select` kann z.B. mit `contains`, `ends_with` oder `starts_with`

```r
df_tidy %&gt;% 
  select(contains("death"))
```

```
## # A tibble: 4 × 2
##   deaths death_rate
##    &lt;dbl&gt;      &lt;dbl&gt;
## 1    723    0.00515
## 2    723    0.00515
## 3    372    0.00363
## 4    372    0.00363
```
]
]

---
----

## dplyr::filter()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit `filter` können die gewünschten Reihen gefiltert werden. So kann ein *subset* des Datensatzes erstellt werden
- Der Ausdruck innerhalb der `filter()` function muss vom Typ *logical* sein (`TRUE`,`FALSE`)

--

.panelset[
.panel[.panel-name[Ausgangsdaten]

```r
df_tidy
```

```
## # A tibble: 4 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
## 2 2022-12-11 TG     140484    723    0.00515
## 3 2022-12-10 BS     102405    372    0.00363
## 4 2022-12-11 BS     102405    372    0.00363
```
]
.panel[.panel-name[Bsp. 1]
Für `filter` können sog. Operatoren verwendet werden (`==`, `!=`, `&gt;=`, `&lt;=`, `&lt;`, `&gt;`) 

```r
df_tidy %&gt;% 
  filter(kanton == "TG")
```

```
## # A tibble: 2 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
## 2 2022-12-11 TG     140484    723    0.00515
```
]
.panel[.panel-name[Bsp. 2]
Filteroptionen können mit `&amp;` (*und*) und `|` (*oder*) verbunden werden.

```r
df_tidy %&gt;% 
  filter(kanton == "TG" &amp; date== "2022-12-10")
```

```
## # A tibble: 1 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
```
]
.panel[.panel-name[Bsp. 3]
Für den Abgleich mit einem Vektor kann der `%in%` Operator verwendet werden.

```r
df_tidy %&gt;% 
  filter(cases %in% c(140484,102405))
```

```
## # A tibble: 3 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-11 TG     140484    723    0.00515
## 2 2022-12-10 BS     102405    372    0.00363
## 3 2022-12-11 BS     102405    372    0.00363
```
]
.panel[.panel-name[Bsp. 4]
Wie die meisten dplyr Funktionen, können auch `filter` Statements beliebig oft aneinander gereiht werden 

```r
df_tidy %&gt;% 
  filter(kanton == "TG") %&gt;% 
  filter(date == "2022-12-10")
```

```
## # A tibble: 1 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
```
]
]

---
----

## Hands-On: filter und select (Zeit: 10 Minuten)

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

1. Lies die Datei **bevnatgeb2021.sas7bdat** aus dem Ordner **Daten** als data.frame ein.

2. Wähle nur die Spalten `geb_day`,`geb_mon`,`geb_year`, `sex`, `nat` und `name` aus.

3. Behalte nur Geburten **nach 2010** deren Staatsangehörigkeit **Schweiz** (8100) ist.

4. Speichere das Resultat in der Variable **geburten_ch_2010**


<div class="countdown" id="timer_188370fe" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
----

## Hands-On: filter und select (Zeit: 10 Minuten)

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[Lösung 1]

Lies die Datei **geburten_mod.rds** aus dem Ordner **Daten** als data.frame ein.


```r
library(dplyr)
# Aus Datenschutzgründen ist der Datensatz anonymisiert
geburten &lt;- readRDS("Daten/geburten_mod.rds")
```
]

.panel[.panel-name[Lösung 2]

Wähle nur die Spalten `geb_day`,`geb_mon`,`geb_year`, `sex`, `nat` und `name` aus.


```r
geburten_ch_2010 &lt;- geburten %&gt;%
  select(geb_day,geb_mon,geb_year,sex,nat,name)
```
]

.panel[.panel-name[Lösung 3]

Behalte nur Geburten **nach 2010** deren Staatsangehörigkeit **Schweiz** (8100) ist.


```r
geburten_ch_2010 &lt;- geburten %&gt;%
  select(geb_day,geb_mon,geb_year,sex,nat,name) %&gt;%
  filter(geb_year &gt; 2010 &amp; nat == 8100)
head(geburten_ch_2010,3)
```

```
## # A tibble: 3 × 6
##   geb_day geb_mon geb_year   sex   nat name        
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       
## 1       6       8     2016     1  8100 Tyler Jason 
## 2       9       8     2016     1  8100 Soraya      
## 3       9       8     2016     1  8100 ADRIAN JOSEF
```
]
]


---
----

## dplyr::mutate()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit `mutate` können neue Spalten z.B. durch Berechnungen erstellt werden
- `mutate` operiert immer reihenweise

.panelset[
.panel[.panel-name[Ausgangsdaten]

```r
df_tidy
```

```
## # A tibble: 4 × 5
##   date       kanton  cases deaths death_rate
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 2022-12-10 TG     140474    723    0.00515
## 2 2022-12-11 TG     140484    723    0.00515
## 3 2022-12-10 BS     102405    372    0.00363
## 4 2022-12-11 BS     102405    372    0.00363
```
]

.panel[.panel-name[Bsp. 1]


```r
df_tidy %&gt;% 
  mutate(kanton_long = case_when(kanton == "TG" ~ "Thurgau",
                   kanton == "BS" ~ "Basel-Stadt"))
```

```
## # A tibble: 4 × 6
##   date       kanton  cases deaths death_rate kanton_long
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;      
## 1 2022-12-10 TG     140474    723    0.00515 Thurgau    
## 2 2022-12-11 TG     140484    723    0.00515 Thurgau    
## 3 2022-12-10 BS     102405    372    0.00363 Basel-Stadt
## 4 2022-12-11 BS     102405    372    0.00363 Basel-Stadt
```
]

.panel[.panel-name[Bsp. 2]


```r
df_tidy %&gt;% 
  mutate(death_percent = deaths/cases *100) %&gt;% 
  mutate(death_percent = round(death_percent,2)) %&gt;% 
  mutate(death_percent = paste0(death_percent," %"))
```

```
## # A tibble: 4 × 6
##   date       kanton  cases deaths death_rate death_percent
##   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;        
## 1 2022-12-10 TG     140474    723    0.00515 0.51 %       
## 2 2022-12-11 TG     140484    723    0.00515 0.51 %       
## 3 2022-12-10 BS     102405    372    0.00363 0.36 %       
## 4 2022-12-11 BS     102405    372    0.00363 0.36 %
```
]
]

---
----
## mutate(): Good to know

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Mit `mutate_all` oder `mutate_at` können alle Variablen bzw. alle Variablen mit einem bestimmten Kriterium gleichzeitig bearbeitet werden.

Das ist nützlich, wenn man die gleiche Operation auf mehrere Spalten anwenden will.


```r
df_tidy %&gt;% 
  mutate_all(as.character) %&gt;% 
  head(3)
```

```
## # A tibble: 3 × 5
##   date       kanton cases  deaths death_rate         
##   &lt;chr&gt;      &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;              
## 1 2022-12-10 TG     140474 723    0.00514685991713769
## 2 2022-12-11 TG     140484 723    0.005146493550867  
## 3 2022-12-10 BS     102405 372    0.00363263512523803
```

---
----

## dplyr::group_by

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit der `group_by` Funktion können Datensätze gruppiert werden. Die Daten an sich werden dadurch allerdings noch nicht verändert.
- Mächtig wird die Funktion erst in Kombination mit anderen Funktionen, wie z.B. `mutate` oder `summarise`

.panelset[
.panel[.panel-name[Ausgangsdaten]

```r
head(geburten_ch_2010,5)
```

```
## # A tibble: 5 × 6
##   geb_day geb_mon geb_year   sex   nat name          
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;         
## 1       6       8     2016     1  8100 "Tyler Jason" 
## 2       9       8     2016     1  8100 "Soraya"      
## 3       9       8     2016     1  8100 "ADRIAN JOSEF"
## 4      10       8     2016     1  8100 "Michaela"    
## 5      12       8     2016     1  8100 ""
```
]

.panel[.panel-name[Bsp. 1]

Neue Variablen nach Gruppen erstellen mit `group_by` und `mutate`


```r
geburten_ch_2010 %&gt;% 
  group_by(geb_year,name) %&gt;% 
  mutate(sum_name_year = n()) %&gt;% head(2)
```

```
## # A tibble: 2 × 7
## # Groups:   geb_year, name [2]
##   geb_day geb_mon geb_year   sex   nat name        sum_name_year
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;               &lt;int&gt;
## 1       6       8     2016     1  8100 Tyler Jason             1
## 2       9       8     2016     1  8100 Soraya                  1
```
]

.panel[.panel-name[Bsp. 2]

Daten zusammenfassen mit `group_by` und `summarise`


```r
geburten_ch_2010 %&gt;% 
  group_by(geb_year) %&gt;% 
  summarise(geb_per_year = n()) %&gt;% head(2)
```

```
## # A tibble: 2 × 2
##   geb_year geb_per_year
##      &lt;dbl&gt;        &lt;int&gt;
## 1     2011           77
## 2     2012           88
```
]
]

---
----

## dplyr::group_by

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

**ACHTUNG:** Sollten Daten nach einem `group_by` in einer neuen Variable gespeichert werden, dann wird die Gruppierung übernommen.
Das kann zu Verwirrung im weiteren Verarbeiten der Daten führen. Daher ist zu empfehlen nach einem `group_by` und der angehängten `mutate` die Gruppierung mit `ungroup` wieder aufzulösen.

Nach einem `summarise` ist diese Auflösung nicht nötig.

.panelset[
.panel[.panel-name[Code 1]

- Ohne `ungroup` 


```r
geburten_group &lt;- geburten_ch_2010 %&gt;% 
  group_by(geb_year,name) %&gt;% 
  mutate(sum_name_year = n())

geburten_group %&gt;% 
  mutate(n = n())
```
]

.panel[.panel-name[Output 1]

- Ohne `ungroup` 


```
## # A tibble: 4 × 8
## # Groups:   geb_year, name [4]
##   geb_day geb_mon geb_year   sex   nat name         sum_name_year     n
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                &lt;int&gt; &lt;int&gt;
## 1       6       8     2016     1  8100 Tyler Jason              1     1
## 2       9       8     2016     1  8100 Soraya                   1     1
## 3       9       8     2016     1  8100 ADRIAN JOSEF             1     1
## 4      10       8     2016     1  8100 Michaela                 1     1
```
]

.panel[.panel-name[Code 2]

- Mit `ungroup`


```r
geburten_ungroup &lt;- geburten_ch_2010 %&gt;% 
  group_by(geb_year,name) %&gt;% 
  mutate(sum_name_year = n()) %&gt;% 
  ungroup()

geburten_ungroup %&gt;% 
  mutate(n = n())
```
]

.panel[.panel-name[Output 2]

- Mit `ungroup`


```
## # A tibble: 4 × 8
##   geb_day geb_mon geb_year   sex   nat name         sum_name_year     n
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                &lt;int&gt; &lt;int&gt;
## 1       6       8     2016     1  8100 Tyler Jason              1   846
## 2       9       8     2016     1  8100 Soraya                   1   846
## 3       9       8     2016     1  8100 ADRIAN JOSEF             1   846
## 4      10       8     2016     1  8100 Michaela                 1   846
```
]
]
---
----
## Hands-On: mutate(), group_by() und summarise()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;




1. Erstelle für den in der vorherigen Aufgabe erstellten Datensatz geburten_ch_2010 eine neue Spalte `geb_date`.&lt;br&gt;
Die Spalte soll das Geburtsdatum im Format tt.mm.jjjj enthalten.&lt;br&gt;
Verwende dazu die `paste0()` Funktion.&lt;br&gt;
Speichere das Resultat unter dem Namen **geburten_ch_2010_date**   

2. Erstelle eine Variable `age`, welche das Alter des Kindes zum heutigen Tag enthält.&lt;br&gt;
**Tipp:** das heutige Datum kann mit `Sys.Date()` ermittelt und verwendet werden. Die variable `age` soll das Alter in vollendeten Lebensjahren beinhalten.

3. Zähle die Geburten pro (Geburts-)Jahr im Datensatz&lt;br&gt;
**Tipp:** Nutze `group_by()` sowie `count()` bzw. `summarise()` und `n()`

<div class="countdown" id="timer_17e10d33" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---
----

## dplyr::join()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Mit den Funktionen aus der `join` Familie können mehrere Datensaätze miteinander verbunden werden.

Es wird dabei zwischen [Filtering joins](https://dplyr.tidyverse.org/reference/filter-joins.html) und [Mutating joins](https://dplyr.tidyverse.org/reference/mutate-joins.html) unterscheiden.

.panelset[
.panel[.panel-name[Filtering joins]

...filtern Zeilen aus x auf der Grundlage des Vorhandenseins oder Fehlens von Übereinstimmungen in y

- `semi_join(x,y)`: gibt alle Zeilen von `x` **mit** einem Match in `y` zurück
- `anti_join(x,y)`: gibt alle Zeilen von `x` **ohne** ein Match in `y` zurük 

]
.panel[.panel-name[Mutating joins]

...fügen Spalten von y nach x hinzu, wobei die Zeilen anhand der Schlüssel abgeglichen werden

- `inner_join(x,y)`: beinhaltet alle Zeilen in `x` die ein match in `y` haben
- `left_join(x,y)`: beinhaltet alle Zeilen in `x`
- `right_join(x,y)`: beinhaltet alle Zeilen in `y`
- `full_join(x,y`: beinhaltet alle Zeilen in `x` und `y`

]
]


---
----

## dplyr::join()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://tavareshugo.github.io/r-intro-tidyverse-gapminder/fig/07-dplyr_joins.svg" alt="https://tavareshugo.github.io/r-intro-tidyverse-gapminder/fig/07-dplyr_joins.svg" width="57%" /&gt;
&lt;p class="caption"&gt;https://tavareshugo.github.io/r-intro-tidyverse-gapminder/fig/07-dplyr_joins.svg&lt;/p&gt;
&lt;/div&gt;

---
----

## dplyr::join()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.pull-left[
**df1: Beliebte Vornamen**


```
## # A tibble: 7 × 4
##     sex nat   name          n
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;
## 1     1 8100  "fabian"    349
## 2     2 8100  "jasmin"    256
## 3     1 8218  "alessio"    43
## 4     2 8218  "alessia"    32
## 5     1 8239  "emre"       22
## 6     2 8239  "selin"      19
## 7     1 8999  ""          586
```

]
.pull-right[
**df2: Länder und Codes**

```
## # A tibble: 4 × 2
##   code  country
##   &lt;chr&gt; &lt;chr&gt;  
## 1 8100  Schweiz
## 2 8218  Italien
## 3 8239  Türkiye
## 4 8256  Kosovo
```
]


---
----

## Mutating joins

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[left_join]


```r
df1 %&gt;% 
  left_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 7 × 5
##     sex nat   name          n country
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;  
## 1     1 8100  "fabian"    349 Schweiz
## 2     2 8100  "jasmin"    256 Schweiz
## 3     1 8218  "alessio"    43 Italien
## 4     2 8218  "alessia"    32 Italien
## 5     1 8239  "emre"       22 Türkiye
## 6     2 8239  "selin"      19 Türkiye
## 7     1 8999  ""          586 &lt;NA&gt;
```

]
.panel[.panel-name[right_join]

```r
df1 %&gt;% 
  right_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 7 × 5
##     sex nat   name        n country
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;  
## 1     1 8100  fabian    349 Schweiz
## 2     2 8100  jasmin    256 Schweiz
## 3     1 8218  alessio    43 Italien
## 4     2 8218  alessia    32 Italien
## 5     1 8239  emre       22 Türkiye
## 6     2 8239  selin      19 Türkiye
## 7    NA 8256  &lt;NA&gt;       NA Kosovo
```

]
.panel[.panel-name[inner_join]


```r
df1 %&gt;% 
  inner_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 6 × 5
##     sex nat   name        n country
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;  
## 1     1 8100  fabian    349 Schweiz
## 2     2 8100  jasmin    256 Schweiz
## 3     1 8218  alessio    43 Italien
## 4     2 8218  alessia    32 Italien
## 5     1 8239  emre       22 Türkiye
## 6     2 8239  selin      19 Türkiye
```
]
.panel[.panel-name[full_join]


```r
df1 %&gt;% 
  full_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 8 × 5
##     sex nat   name          n country
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;  
## 1     1 8100  "fabian"    349 Schweiz
## 2     2 8100  "jasmin"    256 Schweiz
## 3     1 8218  "alessio"    43 Italien
## 4     2 8218  "alessia"    32 Italien
## 5     1 8239  "emre"       22 Türkiye
## 6     2 8239  "selin"      19 Türkiye
## 7     1 8999  ""          586 &lt;NA&gt;   
## 8    NA 8256   &lt;NA&gt;        NA Kosovo
```

]
]



---
----

## Filtering joins

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[semi_join]


```r
df1 %&gt;% 
  semi_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 6 × 4
##     sex nat   name        n
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;int&gt;
## 1     1 8100  fabian    349
## 2     2 8100  jasmin    256
## 3     1 8218  alessio    43
## 4     2 8218  alessia    32
## 5     1 8239  emre       22
## 6     2 8239  selin      19
```

]
.panel[.panel-name[anti_join]

```r
df1 %&gt;% 
  anti_join(df2,by=c("nat"="code"))
```

```
## # A tibble: 1 × 4
##     sex nat   name      n
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;
## 1     1 8999  ""      586
```

]
]

---
----

## Hands-On: Joins

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.pull-left[
**df1**

```
## # A tibble: 3 × 2
##   vorname nachname
##   &lt;chr&gt;   &lt;chr&gt;   
## 1 Peter   Huber   
## 2 Maria   Krause  
## 3 Paul    Gut
```

]
.pull-right[
**df2**

```
## # A tibble: 3 × 2
##   nachname alter
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 Huber       34
## 2 Huber       67
## 3 Meier       18
```
]
.panelset[
.panel[.panel-name[Frage]

Joint man die beiden Datensätze, wie viele Reihen hat der resultierende Datensatz bei einem...
- left join?
- right join?
- inner join?
- full join?

]
.panel[.panel-name[left_join]

```
## # A tibble: 4 × 3
##   vorname nachname alter
##   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;
## 1 Peter   Huber       34
## 2 Peter   Huber       67
## 3 Maria   Krause      NA
## 4 Paul    Gut         NA
```

]
.panel[.panel-name[right_join]

```
## # A tibble: 3 × 3
##   vorname nachname alter
##   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;
## 1 Peter   Huber       34
## 2 Peter   Huber       67
## 3 &lt;NA&gt;    Meier       18
```

]
.panel[.panel-name[inner_join]

```
## # A tibble: 2 × 3
##   vorname nachname alter
##   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;
## 1 Peter   Huber       34
## 2 Peter   Huber       67
```

]
.panel[.panel-name[full_join]

```
## # A tibble: 5 × 3
##   vorname nachname alter
##   &lt;chr&gt;   &lt;chr&gt;    &lt;dbl&gt;
## 1 Peter   Huber       34
## 2 Peter   Huber       67
## 3 Maria   Krause      NA
## 4 Paul    Gut         NA
## 5 &lt;NA&gt;    Meier       18
```

]
]
---
----

## Hands-On: Joins

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;



1. Joine die `geburten_nat` mit dem `codes` Datensatz um den Ländernamen zu den Namensdaten hinzuzufügen&lt;br&gt;
Nutze dafür `left_join()`&lt;br&gt;
Schau dir die Datensätze vorher an, um die gemeinsamen Spalten herauszufinden&lt;br&gt;
Speichere den neuen Datensatz unter dem Namen `geburten_join` 

2. Wie lautet der häufigste männliche Vorname für Kinder mit der Nationalität Nordmazedonien im Datensatz?

<div class="countdown" id="timer_d93b9a24" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---
----
## Good to know: Joins

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Neben den Standard join Operatoren aus dem `dplyr` Package gibt es auch noch das [fuzzyjoin](http://varianceexplained.org/fuzzyjoin/index.html) Package, welches weitere join Möglichkeiten bietet.

Das Package ermöglicht "inexact matching", wie z.B:

- matching ähnlicher strings
- matching numerischer Werte mit einer gewissen Toleranz
- matching numerischer Werte auf bestimmte Intervalle
- u.v.m.

---
----
## Weitere nützliche dplyr Funktionen

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[arrange]

Mit arrange kann die Reihenfolge der Zeilen nach einer Variable im Datensatz sortiert werden. Standardmässig werden die Daten dann aufsteigend sortiert. 


```r
geburten_ch_2010 %&gt;% 
  arrange(geb_year) %&gt;% head(2)
```

```
## # A tibble: 2 × 6
##   geb_day geb_mon geb_year   sex   nat name             
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;            
## 1       4      12     2011     2  8100 RAPHAELA PATRICIA
## 2       6      12     2011     1  8100 Cedric
```

]
.panel[.panel-name[arrange + desc]
Mit der `desc()` Funktion kann man die Daten auch in eine absteigende Sortierung bringen.

```r
geburten_ch_2010 %&gt;% 
  arrange(desc(geb_year)) %&gt;% head(2)
```

```
## # A tibble: 2 × 6
##   geb_day geb_mon geb_year   sex   nat name    
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   
## 1      20       4     2020     2  8100 "Astrit"
## 2      19       4     2020     2  8100 ""
```
]
.panel[.panel-name[slice]
Zeilen können auch per Index gefiltert werden

```r
# extrahiert die Zeilen 10,11 und 12
geburten_ch_2010 %&gt;% 
  slice(10:12)
```

```
## # A tibble: 3 × 6
##   geb_day geb_mon geb_year   sex   nat name 
##     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;
## 1      10       8     2016     2  8100 ""   
## 2       6       8     2016     1  8100 ""   
## 3       2       8     2016     2  8100 ""
```

]
.panel[.panel-name[top_n]
Mit `top_n()` können die Zeilen mit den höchsten (oder niedrigsten) Werten für eine bestimmte Variable gefiltert werden

```r
geburten_ch_2010 %&gt;% 
  group_by(geb_year,name) %&gt;% 
  count() %&gt;% 
  group_by(geb_year) %&gt;% 
  top_n(1,n) %&gt;% 
  head(2)
```

```
## # A tibble: 2 × 3
## # Groups:   geb_year [2]
##   geb_year name      n
##      &lt;dbl&gt; &lt;chr&gt; &lt;int&gt;
## 1     2011 ""       21
## 2     2012 ""       27
```

]
.panel[.panel-name[distinct]
Mit `distinct()` können Duplikate entfernt werden. Dazu werden einfach die Variablen aus denen die Duplikate entfernt werden sollen als Argumente mitgegeben. Setzt man `.keep_all=TRUE`, dann bleiben alle anderen Variablen des data.frames erhalten. Sonst bleiben nur die Spalten, die als Argument angegeben wurden. Bei der Entfernung der Duplikate wird immer der erste Wert behalten, der Rest wird entfernt.



```r
popular_names %&gt;% 
  distinct(geb_year,.keep_all = TRUE) %&gt;% 
  head(2)
```

```
## # A tibble: 2 × 3
## # Groups:   geb_year [2]
##   geb_year name      n
##      &lt;dbl&gt; &lt;chr&gt; &lt;int&gt;
## 1     2011 ""       21
## 2     2012 ""       27
```
]
]
---



























----
## stringr

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Oft muss in der Datenaufbereitung mit Text (=strings) gearbeitet werden. Dafür kann das `stringr` Package verwendet werden.

Für detailliertere Informationen findet sich [hier](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf) ein empfehlenswertes Cheatsheet

Alle Funktionen in stringr beginnen mit str_ und nehmen einen Vektor von Strings (oder einen einzelnen String) als erstes Argument.

Die verwendung von sogenannten *regular expressions* ist möglich.

---
----
## stringr

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[str_detect]
Ermitteln, ob eine bestimmte Zeichenfolge im String enthalten ist.



```r
str_detect(c("Das ist ein Test", "Hello World"),
           pattern = "Test")
```

```
## [1]  TRUE FALSE
```

]
.panel[.panel-name[str_extract]
Text extrahieren


```r
str_extract(c("dasisteinTestmitstrings",
              "das_ist_ein_Test_mit_strings"), 
            pattern = "Test")
```

```
## [1] "Test" "Test"
```

]
.panel[.panel-name[str_replace]
Text ersetzen

```r
str_replace(c("dasisteinTestmitstrings",
              "das_ist_ein_Test_mit_strings_Test"), 
            pattern = "Test",
            replacement = "Versuch")
```

```
## [1] "dasisteinVersuchmitstrings"          
## [2] "das_ist_ein_Versuch_mit_strings_Test"
```
**ACHTUNG:** `str_replace` ersetzt das Pattern lediglich beim ersten Auftreten. Soll jedes Auftreten innerhalb des Strings ersetzt werden, muss die `str_replace_all` Funktion verwendet werden.
]
.panel[.panel-name[str_remove]
Text entfernen

```r
str_remove(c("dasisteinTestmitstrings",
              "das_ist_ein_Test_mit_strings"), 
            pattern = "Test")
```

```
## [1] "dasisteinmitstrings"      "das_ist_ein__mit_strings"
```
**ACHTUNG:** `str_remove` entfernt das Pattern lediglich beim ersten Auftreten. Soll jedes Auftreten innerhalb des Strings entfernt werden, muss die `str_remove_all` Funktion verwendet werden.
]

.panel[.panel-name[str_split]
Text zerteilen

```r
str_split(c("dasisteinTestmitstrings",
              "das_ist_ein_Test_mit_strings"), 
            pattern = "_")
```

```
## [[1]]
## [1] "dasisteinTestmitstrings"
## 
## [[2]]
## [1] "das"     "ist"     "ein"     "Test"    "mit"     "strings"
```
`str_split_fixed` und `str_split_n` sind verwandte Funktionen, die ebenfalls Text zerteilen können un zusätzliche Spezifikationen erlauben.
]
.panel[.panel-name[str_trim]
Leerzeichen an Anfang und Ende eines Strings entfernen

```r
str_trim(c("    Hello World      ", "    Test"))
```

```
## [1] "Hello World" "Test"
```

]
]

---
----
## Regular Expressions
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Regular Expressions (kurz "Regex" genannt) sind eine Art von Zeichenfolgen, die zur Suche nach Mustern in Texten verwendet werden. 

Mit Regex kann man komplexe Suchmuster definieren, die aus bestimmten Zeichenfolgen, Buchstaben, Zahlen, Sonderzeichen und Platzhaltern bestehen.

Beispiele für den Einsatz von Regex sind das Extrahieren von Telefonnummern aus Texten, das Überprüfen der Gültigkeit von E-Mail-Adressen oder das Ersetzen von bestimmten Zeichenfolgen in einer Datei.

---
----
## Regular Expressions: Beispiele
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[Telefonnummern extrahieren]
- Jede Zahl (digit) kann mit dem regex `\d` extrahiert werden.

```r
str_extract_all(c("Meine Nummer ist die 058345-5367",
                  "Meine Adresse ist Grabenstrasse 8, 8510 Frauenfeld"), 
                pattern = "\\d{6}-\\d{4}")
```

```
## [[1]]
## [1] "058345-5367"
## 
## [[2]]
## character(0)
```


]
.panel[.panel-name[Email extrahieren]
-  `.` (Punkt): matcht alles ausser Zeilenumbrüche
- `+`: einer oder mehr des voangengangenen Wertes
- `*`: null oder mehr des voangengangenen Wertes
- `[^\\s]`: matcht alles ausser Whitespaces
- `?\\.ch` und `?@`: Match muss mit `\\.ch` bzw. `@` enden

```r
str_extract_all(c("Meine Mailadresse ist felix.lorenz@tg.ch",
                  "felix.lorenz@tg wird nicht gematcht"), 
                pattern = "[^\\s]*?@.+?\\.ch")
```

```
## [[1]]
## [1] "felix.lorenz@tg.ch"
## 
## [[2]]
## character(0)
```
]
.panel[.panel-name[Weitere nützliche Regex]
Im Netz finden sich jede Menge nützliche Sammlungen

- [Top 15 Commonly Used Regex](https://digitalfortress.tech/tips/top-15-commonly-used-regex/)
- [Regex Tutorial](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Regexe.html)
- [Regex schreiben und testen](https://regexr.com/)
- etc.

]
]
---
----
## Hands-On: Arbeiten mit stringr und Regular Expressions
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

1. Bringe `abstimmungen` in ein Tidy Format, sodass jeder Wert in `Ergebnis` einer eigenen Spalte entspricht&lt;br&gt;
Die dazugehörigen Werte sollen aus der Spalte `Volksabstimmungen (Ergebnisse Ebene Kanton seit 1866)` kommen.&lt;br&gt;
Nutze das tidyr package und eine der vohin besprochenen Funktionen um die Tabelle zu verbreitern (wide Format)&lt;br&gt;
Speichere das Ergebnis in `abstimmungen_tidy` 

2. Erstelle eine neue Variable `date`.&lt;br&gt;
Extrahiere dazu das Datum aus der Spalte `Datum und Vorlage`&lt;br&gt;
Nutze dafür den Regex `\\d\\d\\d\\d-\\d\\d-\\d\\d`

3. Entferne das Datum aus der Spalte `Datum und Vorlage` und wandle die `date` Spalte in ein von R lesbares Datum um.

4. Entferne die Leerzeichen anführenden Leerzeichen aus der Spalte `Datum und Vorlage` (" Test " -&gt; "Test")

<div class="countdown" id="timer_eff8de06" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---
----
## Good to know: stringi

`stringr` enthält zwar viele nützliche Funktionen im Umgang mit Strings, ist aber auf das Nötigste beschränkt. Eine weitreichende Erweiterung stellt das `stringi` package dar. In diesem Package sind wahrscheinlich alle Funktionen enthalten, die im Umgang mit Text notwendig sein könnten. Im Unterschied zu `stringr` beginnen `stringi` Funktionen nicht mit *str_*, sondern mit *stri_*
---

























----
## lubridate
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
- Da das arbeiten mit Datumsangaben in R oft unintuitiv ist, wurde das `lubridate` Package entwickelt
- Mit `lubridate` Können Datums- und Zeitangaben deutlich einfacher verarbeitet werden, als mit base R.

- `lubridate` kann sowohl Daten vom Typ `date` (Datum auf Tagesbasis) als auch vom Typ `datetime` (Genaues Datum mit Uhrzeit) verarbeiten.

 
---
----
## lubridate: Nützliche Funktionen
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
.panelset[
.panel[.panel-name[date]
- `lubridate` bietet Funktionen an, die quasi jedes Datumsformat erkennen und umwandeln kann. 
- Wichtig ist einzig die Reihenfolge (Tag-Monat-Jahr -&gt; `dmy()`; Jahr-Monat-Tag -&gt; `ymd()`)



```r
ymd("20221212")
```

```
## [1] "2022-12-12"
```

```r
dmy("02.03.2023")
```

```
## [1] "2023-03-02"
```


]
.panel[.panel-name[datetime]
-  gleiches gilt für Daten vom Typ `datetime` (gleiches Prinzip)

```r
dmy_hms("02.03.2023 11:41:12 Uhr")
```

```
## [1] "2023-03-02 11:41:12 UTC"
```
]
.panel[.panel-name[Daten runden und extrahieren]
- will man Daten auf z.B. auf Jahresbasis zusammenfassen müssen tgesaktuelle Daten gerundet werden


```r
new_date &lt;- round_date(dmy_hms("02.03.2023 11:41:12 Uhr"),unit = "year")
new_date
```

```
## [1] "2023-01-01 UTC"
```

- wenn nun nur das Jahr angezeigt werden soll, bietet `lubridate` ebenfalls eine Lösung


```r
year(new_date)
```

```
## [1] 2023
```
]
]


---
----
## Hands-On: lubridate und das Arbeiten mit Datumsangaben
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
1. Betrachten wir den Datensatz `geburten`. Wir möchten das Geburtsdatum noch genauer wissen und beziehen deshalb   die Geburtsstunde des Kindes mit ein. Demnach bilden wir aus dem Geburtsjahr (geb_year), dem Geburtsmonat (geb_mon),   dem Geburtstag und der Geburtsstunde eine neue Variable `geb_fulldate`, die ein von R lesbares Datum vom Typ `datetime` enthält.&lt;br&gt;
Selektiere den Datensatz vor der Berechnung so, dass nur die benötigten Variablen enthalten sind.
Erstelle einen neuen Datensatz `geburten_time` und füge die neue Spalte hinzu.

2. Was ist der Grund für die Warning Message wonach das parsing bei einigen Zeilen fehlgeschlagen ist?

3. Wie könnte man dieses Problem theoretisch lösen?

<div class="countdown" id="timer_f29d0c5b" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---






















----

## Listen
.panelset[
.panel[.panel-name[Basics]
- im Unterschied zu Vektoren können Listen unterschiedlichste Datentypen enthalten

- jedes Listenelement kann man sich als eine Art  Container vorstellen, in dem der jeweilige Inhalt liegt

- Listen werden mit `list()` initialisiert

- jedem Listenelement kann ein Name zugewiesen werden
]
.panel[.panel-name[Zugriff (1)]
- auf Listenelmente kann *direkt* über deren Index oder Namen (wenn vorhanden) zugegriffen werden
- wichtig dabei sind die doppelten eckigen Klammern `[[]]` für direkten Zugriff

```r
new_list &lt;- list(a="hallo",4)
new_list[["a"]]
```

```
## [1] "hallo"
```

```r
new_list[[2]]
```

```
## [1] 4
```
]
.panel[.panel-name[Zugriff (2)]
- mit einfachen eckigen Klammern `[]` greift man über den Index auf den Container zu und erhält als Ergebnis eine Liste


```r
new_list[2]
```

```
## [[1]]
## [1] 4
```

```r
class(new_list[2])
```

```
## [1] "list"
```
]
.panel[.panel-name[Nested Lists]
- Listen können beliebig tief verschachtelt werden (*nested*)
- hierfür wird `list()` innerhalb der Liste verwendet
- Listen können so z.B. einfach in `JSON` umgewandelt werden (ähnliches Prinzip)

```r
nested_list &lt;- list(char = list(a = "halo",b="hi"), nums = list(1,2))
jsonlite::toJSON(nested_list,auto_unbox = T) %&gt;% jsonlite::prettify()
```

```
## {
##     "char": {
##         "a": "halo",
##         "b": "hi"
##     },
##     "nums": [
##         1,
##         2
##     ]
## }
## 
```
]
.panel[.panel-name[Nested Lists (2)]
- für den Zugriff können Indizes und Namen verschachtelt werden
- auch der `$`-Operator kann verwendet werden


```r
nested_list &lt;- list(char = list(a = "halo",b="hi"), nums = list(1,2))
nested_list$char$a
```

```
## [1] "halo"
```

```r
nested_list[["nums"]][[2]]
```

```
## [1] 2
```
]
]

---
----
## Listen (2)

.panelset[
.panel[.panel-name[Listen Bearbeiten]
- neue Listenelmente können einfach per Namen oder Index hinzugefügt werden

```r
new_list[[3]] &lt;- "neues Element"
new_list[["test"]] &lt;- "neu"
new_list
```

```
## $a
## [1] "hallo"
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] "neues Element"
## 
## $test
## [1] "neu"
```
]
.panel[.panel-name[Unlisten]
- Listen können mit `unlist()` zu Vektoren (soweit möglich) umgewandelt werden
- eine Liste von `data.frames` kann mit `dplyr::bind_rows` zu einem zusammenhängenden Datensatz umgewandelt werden

```r
unlist(new_list)
```

```
##               a                                            test 
##         "hallo"             "4" "neues Element"           "neu"
```
]
.panel[.panel-name[Listen mergen]
- mehrere Listen können mit dem `c()` Operator zusammengefügt werden


```r
full_list &lt;- c(new_list,nested_list)
```
]
]
---























----

## Conditional Statements

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- `Conditional Statements` (Bedingungen) sind hilfreich, wenn es z.B. darum geht numerische Daten in Kategorien einzuteilen

- "Wenn x dann y sonst z"

- in `dplyr`-Pipelines kann dazu entweder das klassische `ifelse()` oder die `case_when()` Funktion verwendet werden


---
----

## ifelse

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

.panelset[
.panel[.panel-name[Syntax]


```r
# Genereller Syntax
ifelse(Bedingung,wenn_wahr,wenn_falsch)
```
Mehrere `ifelse` Funktionen können auch verschachtelt werden. Anstelle eines `wenn_falsch` Wert wird dann ein weiteres `ifelse` Statement eingefügt.

```r
ifelse(Bedingung1,wenn_wahr1,
       ifelse(Bedingung2, wenn_wahr2, wenn_falsch))
```

]
.panel[.panel-name[Anwendung]

```r
geburten %&gt;% 
  select(age_m) %&gt;% 
  mutate(age_class = ifelse(age_m&lt;18,"unter 18",
                            ifelse(age_m&gt;=18, "18 oder älter", "unbekannt"))) %&gt;% 
  head(3)
```

```
## # A tibble: 3 × 2
##   age_m age_class    
##   &lt;dbl&gt; &lt;chr&gt;        
## 1    28 18 oder älter
## 2    20 18 oder älter
## 3    31 18 oder älter
```
]
.panel[.panel-name[Problem]

Bei vielen verschachtelten `ifelse` Funktionen wird der Code unübersichtlich (zu viele Klammern, schwer zu bearbeiten)


```r
geburten %&gt;% 
  select(age_m) %&gt;% 
  mutate(age_class = ifelse(age_m &lt; 20,"unter 20",
                            ifelse(age_m&gt;=20 &amp; age_m&lt;25, "20 bis 24", 
                                   ifelse(age_m&gt;=25 &amp; age_m&lt;30, "25 bis 29", 
                                          ifelse(age_m&gt;=30 &amp; age_m&lt;35, "30 bis 34", 
                                                 ifelse(age_m&gt;=35 &amp; age_m&lt;40, "35 bis 39", 
                                                        ifelse(age_m&gt;=40, "40 und älter", "unbekannt"))))))) 
```
]
]


---
----

## dplyr::case_when

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

`case_when` bietet die Möglichkeit den Code in einer übersichtlicheren Form darzustellen.

.panelset[
.panel[.panel-name[Syntax]

- das Tilde-Symbol (`~`) kann mit `Ctrl+Alt+^` (zweimal drücken) erzeugt werden


```r
# Genereller Syntax
case_when(Bedingung ~ wenn_wahr,
          TRUE ~ wenn_falsch)
```
Mehrere Bedingungen werden einfach mit Komma getrennt. `TRUE ~ x` kennzeichnet den Wert der zurückgegeben wird, wenn keine Bedingung zutrifft.

```r
case_when(Bedingung1 ~ wenn_wahr1,
          Bedingung2 ~ wenn_wahr2,
          TRUE ~ wenn_falsch)
```

]
.panel[.panel-name[Anwendung]

```r
geburten %&gt;% 
  select(age_m) %&gt;% 
  mutate(age_class = case_when(age_m&lt;18 ~"unter 18",
                               age_m&gt;=18 ~ "18 oder älter",
                               TRUE ~ "unbekannt")) %&gt;% 
  head(3)
```

```
## # A tibble: 3 × 2
##   age_m age_class    
##   &lt;dbl&gt; &lt;chr&gt;        
## 1    28 18 oder älter
## 2    20 18 oder älter
## 3    31 18 oder älter
```
]
.panel[.panel-name[Vorteil ggü. ifelse]

Mehrere Bedingungen können einfach unterinander geschrieben werden, ohne das jedes Mal eine neue Klammer geöffnet werden muss.

Der Code wird leichter lesbar und einfacher zu bearbeiten.

```r
geburten %&gt;% 
  select(age_m) %&gt;% 
  mutate(age_class = case_when(age_m &lt; 20 ~ "unter 20",
                               age_m&gt;=20 &amp; age_m&lt;25 ~ "20 bis 24",
                               age_m&gt;=25 &amp; age_m&lt;30 ~ "25 bis 29",
                               age_m&gt;=30 &amp; age_m&lt;35 ~ "30 bis 34",
                               age_m&gt;=35 &amp; age_m&lt;40 ~ "35 bis 39",
                               age_m&gt;=40 ~ "40 und älter",
                               TRUE ~ "unbekannt"))
```

```
## # A tibble: 10,000 × 2
##    age_m age_class
##    &lt;dbl&gt; &lt;chr&gt;    
##  1    28 25 bis 29
##  2    20 20 bis 24
##  3    31 30 bis 34
##  4    24 20 bis 24
##  5    38 35 bis 39
##  6    27 25 bis 29
##  7    26 25 bis 29
##  8    20 20 bis 24
##  9    27 25 bis 29
## 10    34 30 bis 34
## # ℹ 9,990 more rows
```
]
]

---
----
## Hands-On: Conditional Statements: case_when und ifelse

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Erstelle den Datensatz `geburten_nat_eltern` aus dem `geburten` Datensatz:
- **Spalten auswählen:** behalte nur stat_jahr, nat_m und nat_V
- **Filtern:** nur Daten behalten die keine NAs in nat_m oder nat_V enthalten (Staatsangehörigkeit Mutter und Vater) besitzen

Verwende Conditional Statements um die neue Variable `eltern_nat_type` zu erstellen:
- Wenn **beide Elternteile Ausländer** sind, soll **"beide Elternteile Ausländer"** eingetragen werden  
- Wenn **beide Elternteile Schweizer** sind, soll **"beide Elternteile Schweizer"** eingetragen werden    
- Wenn der **Vater Ausländer** ist, soll **"Vater Ausländer"** eingetragen werden                       
- Wenn die **Mutter Ausländerin** ist, soll **"Mutter Ausländer"** eingetragen werden                           
- Wenn **keine der Kategorien zutrifft** soll **"unbekannt"** eingetragen werden (Kontrolle) 


---
----

## baseR: if...else

- eine andere Form von `Conditional Statements` ist die in anderen Sprachen oft verwendete `if...else` Notierung
- diese wird vor allem in Loops und Funktionen  verwendet
- ein `if` braucht in R nicht zwingend ein `else` 

.panelset[
.panel[.panel-name[mit else]


```r
x = 3

if (x %% 2 == 0){
  print("x ist eine gerade Zahl")
} else {
  print("x ist eine ungerade Zahl")
}
```

```
## [1] "x ist eine ungerade Zahl"
```

]
.panel[.panel-name[ohne else]

```r
x = 4

if (x %% 2 == 0){
  print("x ist eine gerade Zahl")
}
```

```
## [1] "x ist eine gerade Zahl"
```
]
]



---
----

## baseR: if...else

.panelset[
.panel[.panel-name[Bsp. 1]
Ein `else` Statement ist nicht unbedingt notwendig, wenn nur in einem einzigen Prüffall etwas unternommen werden soll

```r
x = 3

if (x %% 2 != 0){
  x &lt;- x+1
} 

x
```

```
## [1] 4
```

]
.panel[.panel-name[Bsp. 2]
Wenn mehrere, sich gegenseitig ausschliessende Bedingungen abgeprüft werden sollen, kann die spezielle `else if` Schreibweise verwendet werden


```r
alter &lt;- 45

if (alter &gt;= 70) {
  altersklasse &lt;- "70 und älter"
} else if (alter &gt;= 50) {
  altersklasse &lt;- "50 bis 69"
} else if (alter &gt;= 30) {
  altersklasse &lt;- "30 bis 49"
}
print(altersklasse)
```

```
## [1] "30 bis 49"
```
]

.panel[.panel-name[Bsp. 3]
Für kompliziertere Prüfungen können `if` statements auch verschachtelt werden

```r
dienstjahre &lt;- 5
bewertung &lt;- "Gut"

if (bewertung == "Sehr gut"){
  bonus &lt;- 5000
} else if (bewertung == "Gut"){
  if (dienstjahre&gt;=10){
    bonus &lt;- 3000
  } else {
    bonus &lt;- 2500
  }
} else {
  bonus &lt;- 0
}
```

]
]
---


























----
## baseR: loops und apply

- grundlegender Baustein in allen Programmiersprachen

- wird verwendet um Code wiederholt auszuführen (Loop = Schleife)

- ist dort nützlich, wo es vieler Iterationen bedarf

- in allen Programmiersprachen gibt es `for` und `while` Loops

- R bietet zusätzlich noch die Funktionen aus der `apply` Familie, die ein ähnliches Ergebnis liefern

- Wenn man einen Loop erstellen möchte, beginnt man am besten damit, den gewünschten Arbeitsablauf auf *ein* Listenelement anzuwenden.

---
----

## baseR: for-loop

.pull-left[
**Für jedes Element `i` in Vektor `x` führe Hauptteil aus**
&lt;br&gt;
&lt;br&gt;
`for` Loops bestehen aus zwei Bestandteilen:
  1. eine Kopfzeile, die die Anzahl an Iterationen angibt (in runden Klammern `()`)
  2. einen Hauptteil, der einen Codeblock enthält, der bei jeder Iteration einmal ausgeführt wird (in geschweiften Klammern `{}`)



```r
for (i in x){ # Kopfzeile
   # Hauptteil
  do_something()
}
```
  
]
.pull-right[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/forloop.PNG" alt="https://universeofdatascience.com/wp-content/uploads/2021/06/Loops_in_R-1024x576.png" width="70%" /&gt;
&lt;p class="caption"&gt;https://universeofdatascience.com/wp-content/uploads/2021/06/Loops_in_R-1024x576.png&lt;/p&gt;
&lt;/div&gt;

]


---
----

## baseR: for-loop

.panelset[
.panel[.panel-name[Bsp. 1]
- Zuweisungen sind essentiell bei Loops
- Wenn Daten nicht zugewiesen werden sind sie nachher nicht im  Environment verfügbar
- Zuweisungen die ausschliesslich innerhalb des loops geschehen sind nicht im globalen environment verfügbar

```r
for (i in 1:3){
  temp &lt;- paste0("Iteration Nr. ",i)
}
temp
```

```
## [1] "Iteration Nr. 3"
```

]
.panel[.panel-name[Bsp. 2]
- Elemente können auch direkt verwendet werden

```r
new_list &lt;- list()
for (elem in c("A","B","C")){
  new_list[[elem]] &lt;- tolower(elem)
}
new_list
```

```
## $A
## [1] "a"
## 
## $B
## [1] "b"
## 
## $C
## [1] "c"
```
]
.panel[.panel-name[Bsp. 3]
- mit `seq_along` werden die Indizes (=Positionen) für einen Vektor gebildet


```r
vec &lt;- c("A","B","C")
for (i in seq_along(vec)){
  print(paste0(vec[i],i))
}
```

```
## [1] "A1"
## [1] "B2"
## [1] "C3"
```
]
]

---
----

## baseR: while-loop

.pull-left[
**Solange `i` kleiner gleich `y`  führe Hauptteil aus und erhöhe `i` anschliessend um 1**
&lt;br&gt;
&lt;br&gt;
- `while` Loops können, wenn fehlerhaft programmiert, unendlich lange laufen
- der Parameter `i` muss in diesem Fall vor dem Loop initialisiert werden




```r
i = 1
while (i &lt;= y){
  do_something()
  i=i+1
}
```
  
]
.pull-right[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/whileloop.PNG" alt="https://universeofdatascience.com/wp-content/uploads/2021/06/Loops_in_R-1024x576.png" width="70%" /&gt;
&lt;p class="caption"&gt;https://universeofdatascience.com/wp-content/uploads/2021/06/Loops_in_R-1024x576.png&lt;/p&gt;
&lt;/div&gt;

]

---
----
## baseR: while-loop

.panelset[
.panel[.panel-name[Bsp. 1]
Wie oft wird `"Hello World"` im unten stehenden while Loop ausgegeben?

```r
y = 3
i = 1

while (i &lt;= y){
  print("Hello World")
}
```

]
.panel[.panel-name[Lösung. 1]
Abbruchbedingungen müssen korrekt initialisert werden um einen unendlichen Loop zu vermeiden

```r
y = 3
i = 1

while (i &lt;= y){
  print("Hello World")
  i &lt;- i+1
}
```

```
## [1] "Hello World"
## [1] "Hello World"
## [1] "Hello World"
```
]
]


---
----
## baseR: Loops und Conditional Statements
- kombiniert sind Loops und Conditional Statements mächtige Werkzeuge in R
- elementar sind dafür die Befehle `break` und `next`

.panelset[
.panel[.panel-name[break]
Mit `break` kann ein Loop an einer bestimmten Stelle (z.B. bei Erfüllung einer bestimmten Bedingung) vorzeitigabgebrochen werden.

```r
for (i in c(1,3,6,8)){
  if (i %% 2 == 0){
    print(i)
    break
  }
}
```

```
## [1] 6
```

]
.panel[.panel-name[next]
Mit `next` kann zur nächsten Iteration gesprungen werden ohne den gesamten Codebody auszuführen

```r
for (i in c(1,2,3,5)){
  if (i %% 2 == 0){
    next # alles nach dieser Zeile wird übersprungen
  }
  print(i)
}
```

```
## [1] 1
## [1] 3
## [1] 5
```
]

]

---
----

## Hands-On: Loops und Conditional Statements


.panelset[
.panel[.panel-name[Aufgabe]
Lade den Datensatz `Daten/firma.rds` und berechne die jährlichen Auszahlungsbeträge pro Mitarbeiter inklusive Boni:

- Mitarbeiter mit einem Monatslohn über 10000 bekommen keinen Bonus
- **Sehr Gut** bewertete Mitarbeiter bekommen einen Bonus in Höhe von **70% ihres Monatseinkommens**
- **Gut** bewertete Mitarbeiter bekommen einen Bonus von **40% ihres Monatseinkommens**, bei **10 oder mehr Dienstjahren** bekommen sie **50%**
- Bewertungen, die weder `Gut` noch `Sehr Gut` sind bekommen den Standardbonus von **300 CHF**

&lt;p&gt;Schreibe einen Loop, welcher eine Liste befüllt mit dem String "NAME erhält AUSZAHLUNG CHF im Jahr inkl. Bonus" für jede/n MitarbeiterIn im Datensatz.&lt;/p&gt;
&lt;p&gt;Sollte ein/e MitarbiertIn keinen Bonus erhalten, sollte der String wie folgt aussehen: "NAME erhält AUSZAHLUNG CHF im Jahr. NAME erhält keinen Bonus"&lt;/p&gt;

]
.panel[.panel-name[Tipps]
**Tipps:**
- Nutze einen for loop
- Arbeite die Bedingungen der Reihe nach ab
- Verwende verschachtelte if Statements, wenn mehrere bedingungen erfüllt sein müssen
]

.panel[.panel-name[Ergebnis]

```
## [[1]]
## [1] "Marta erhält 144000 CHF im Jahr. Marta erhält keinen Bonus."
## 
## [[2]]
## [1] "Mario erhält 120650 CHF im Jahr inkl. Bonus."
## 
## [[3]]
## [1] "Miro erhält 76200 CHF im Jahr inkl. Bonus."
## 
## [[4]]
## [1] "Moni erhält 52080 CHF im Jahr inkl. Bonus."
## 
## [[5]]
## [1] "Theo erhält 192000 CHF im Jahr. Theo erhält keinen Bonus."
## 
## [[6]]
## [1] "Karla erhält 90300 CHF im Jahr inkl. Bonus."
```
]
]


---
----
## apply vs. loops

Die apply-Famile bietet eine Alternative zu klassischen loops.


.panelset[
.panel[.panel-name[Vorteile]

- man benötigt deutlich weniger Code (keine Zuweisungen, Counter, Abbruchbedingungen etc.)

- beugt dem Erzeugen von "Spaghetti-Code" vor, da leichter lesbar

- Variablen innerhalb der Funktion werden nicht im Global Environment gespeichert (keine Gefahr der versehentlichen Überschreibung)

]
.panel[.panel-name[Nachteile]

- kompliziertere Abläufe können mit den apply Funktionen nicht nativ realisiert werden

- klassische Loops können viel feiner definiert werden

- Es können Iterationen erzeugt werden, bei denen das Ergebnis auf der vorigen Iteration beruht

**Ein generelles Ablehnen von Loops, wie es von manchen Autoren propagiert wird ist mMn Quatsch!**
]
]

---
----
## Die apply-Familie

Aus der Erfahrung sind `lapply, sapply` und `apply` die am meisten genutzen Funktionen.

.panelset[
.panel[.panel-name[lapply]
Anwendung einer Funktion auf jedes Element einer Liste/eines Vektors und gibt eine Liste zurück.


```r
num_list &lt;- list(a = c(3,8,6), b = c(1,15,3), c = c(32,15,16))

lapply(num_list, mean)
```

```
## $a
## [1] 5.666667
## 
## $b
## [1] 6.333333
## 
## $c
## [1] 21
```

]
.panel[.panel-name[sapply]
Gleiche Funktionsweise wie `lapply`, gibt aber - wenn möglich - einen Vektor und sonst eine Matrix als Ergebnis zurück.


```r
sapply(num_list, mean)
```

```
##         a         b         c 
##  5.666667  6.333333 21.000000
```
]
.panel[.panel-name[tapply &amp; aggregate]
Berechnung einer Kennzahl (mean, median, min, max, etc.) für jede Faktor-Variable in einem Vektor.

```r
df &lt;- data.frame(fac = c("a","a","b","b","c","c"),
                num = c(4,8,6,5,7,9))

tapply(df$num, as.factor(df$fac),mean)
```

```
##   a   b   c 
## 6.0 5.5 8.0
```

]
.panel[.panel-name[mapply]
Anwendung einer Funktion auf die korrespondierenden Elemente von mehreren Listen.

```r
num_list &lt;- list(a = c(3,8,6), b = c(1,15,3), c = c(32,15,16))
num_list2 &lt;- list(a = c(1,2,3), b = c(4,5,6), c = c(7,8,9))

mapply(sum, num_list, num_list2)
```

```
##  a  b  c 
## 23 34 87
```

]
.panel[.panel-name[apply]
Anwendung einer Funktion auf die Elemente eines data.frames oder einer Matrix. Gibt Vektor oder Liste zurück.
Apply kann entweder reihenweise, spaltenweise oder elementweise operieren.

```r
df &lt;- data.frame(fac = c("a","a","b","b","c","c"),
                num = c(4,8,6,5,7,9))

apply(df, 1, paste0, collapse="_")
```

```
## [1] "a_4" "a_8" "b_6" "b_5" "c_7" "c_9"
```
]
]

---
----
## Die apply-Familie: Syntax

In allen Funktionen aus der `apply`-Familie können Funktionen mit oder ohne Parameter oder eigene sog. [anonymus functions](https://coolbutuseless.github.io/2019/03/13/anonymous-functions-in-r-part-1/) verwednet werden.
.panelset[
.panel[.panel-name[Generell]
Bei allen `apply`-Funktionen muss ein Objekt (oder mehrere) sowie eine Funktion angegeben werden, welche auf die Elemente des Objekts angewendet wird.

Bei `lapply` kann dies eine Liste oder ein Vektor sein, welche als erstes Argument an die Funktion mitgegeben wird. Das zweite Argument ist die Funktion.


```r
# Generell
lapply(vec_or_list, func)
```
]
.panel[.panel-name[Ohne Args.]
Wenn keine zusätzlichen Argumente für diei Funktion benötigt werden (z.B. `mean()`), kann die Funktion einfach **ohne Klammern** als Argument mitgegeben werden.


```r
# Keine Argumente
lapply(num_list, mean)
```

```
## $a
## [1] 5.666667
## 
## $b
## [1] 6.333333
## 
## $c
## [1] 21
```
]
.panel[.panel-name[Mit Args.]
Argumente, welche normalerweise in die Klammer hinter der Funktion geschrieben werden (`mean(.,na.rm=TRUE)`), werden im Falle von `apply`-Funktionen mit Komma getrennt aufgelistet (`mean,na.rm=TRUE`)


```r
# Mit Argumenten
lapply(num_list[1:2], mean,na.rm=TRUE)
```

```
## $a
## [1] 5.666667
## 
## $b
## [1] 6.333333
```
]
.panel[.panel-name[Anonym. (1)]
[Anonymus Functions](https://coolbutuseless.github.io/2019/03/13/anonymous-functions-in-r-part-1/) (auch *lambda expression* genannt) sind Funktionen, denen kein Name zugeordnet wird und die nur im Zusammehang der apply Funktion existieren


```r
# Mit Argumenten
lapply(num_list[1:2], function(x){
  temp &lt;- paste0("Die Summe ist ",sum(x))
  return(temp)
})
```

```
## $a
## [1] "Die Summe ist 17"
## 
## $b
## [1] "Die Summe ist 19"
```
]
.panel[.panel-name[Anonym. (2)]
Um den Code übersichtlicher zu gestalten und die ungewohnte Schreibweise mit der Kommatrenung zu vermeiden, können auch andere Funktionen als `Anonymus Functions` notiert werden.  


```r
# Mit Argumenten
lapply(num_list[1:2], function(x){
  mean(x,na.rm=TRUE)
})
```

```
## $a
## [1] 5.666667
## 
## $b
## [1] 6.333333
```

]
]
---
----
## Anwendungsbeispiel: Mehrere Files einlesen





```r
abstimmungen_path &lt;- "Daten/Ebene_Gemeinden" 
csv_files &lt;- list.files(path = abstimmungen_path, pattern = "*.csv", full.names = T) 
```
Alle gezeigten Beispiele liefern dasselbe Ergebnis

.panelset[
.panel[.panel-name[for-loop]

```r
for_list &lt;- list()
for(file in csv_files){
  for_list[[file]] &lt;- read_csv2(file,
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
}
```

]
.panel[.panel-name[while-loop]

```r
while_list &lt;- list()
i = 1
while(i &lt;= length(csv_files)){
  while_list[[i]] &lt;- read_csv2(csv_files[i],
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
  i = i + 1
}
```

]
.panel[.panel-name[lapply]

```r
lapply_list &lt;- lapply(csv_files,function(file){
  df &lt;- read_csv2(file,
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
  return(df)
})
```

]
]
---
----
## Hands-On: apply-Funktionen

*Gegeben ist ein Auszug aus dem Mikrezensus Mobilität und Verkehr 2021 (haush_sample.rds) sowie eine Liste von Fahrzeugklassen*

Für jede Fahrzeuklasse soll ein Datensatz erstellt werden, welcher den Mittelwert und die Gesamtnzahl der Fahrzeuge in der entsprechenden Fahrzeugklasse pro Bezirk enthält. Verwende eine passende apply Funktion.

**Erläuterung:**
- Reihen bei denen die Anzahl kleiner 0 ist sind `NAs` und müssen entfernt werden
- filtere die entsprechende Fahrzeugklasse
- gruppiere die Daten nach Bezirk
- nutze summarise um die Kennzahlen zu errechnen

**TIPP:** Wenn man Funktionen in einem Loop oder einer apply Funktion verwenden möchte, beginnt man am besten damit, die Funktion auf *ein* Listenelement anzuwenden. Anschliessend kann man den Arbeitsablauf in eine Schleife packen. 



---
----
## purrr: Iterationen im tidyverse

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Mit den `map` Funktionen aus dem `purrr` Package können ebenfalls schleifenartige Iterationen durchgeführt werden (wie `apply`).

- Der Vorteil gegenüber `apply` Funktionen und klassischen Loops liegt darin, dass `map` Funktionen in eine mit `%&gt;%` oder `|&gt;` erzeugte Pipeline integriert werden können

- Link zum [Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf)

.panelset[
.panel[.panel-name[for-loop]

```r
for_list &lt;- list()
for(file in csv_files){
  for_list[[file]] &lt;- read_csv2(file,
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
}
```

]
.panel[.panel-name[while-loop]

```r
while_list &lt;- list()
i = 1
while(i &lt;= length(csv_files)){
  while_list[[i]] &lt;- read_csv2(csv_files[i],
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
  i = i + 1
}
```

]
.panel[.panel-name[lapply]

```r
lapply_list &lt;- lapply(csv_files,function(file){
  df &lt;- read_csv2(file,
                  locale = locale(encoding = "latin1"),
                  col_types = cols(.default = "c"))
  return(df)
})
```

]
.panel[.panel-name[map]

```r
map_list &lt;- csv_files %&gt;% 
  map(read_csv2,
      locale = locale(encoding = "latin1"),
      col_types = cols(.default = "c"))
```
]
]

---
----
## purr: Tilde-Punkt Notierung für Funktionen

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- Um den Code übersichtlicher zu gestalten, kann die die Tilde-Punkt-Verknüpfung für anonyme Funktionen verwenden 

**Aus**

```r
function(x){
  sum(x)
}
```

**wird** 


```r
~{sum(.x)}
```

Diese Schreibweise ist kein Muss, wird aber bei `purrr` oft verwendet. Es ist daher wichtig zu verstehen, was diese Schreibweise bedeutet, um nachher z.B. Beiträge auf `StackOverflow` verstehen zu können.

---
----
## purrr::map()

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- je nach gewünschtem Output unterscheiden sich die `map` Funktionen

.panelset[
.panel[.panel-name[map]
- `map` ist im Prinzip äquivalent zu `lapply`

```r
# Liste von CSV files einlesen
# Wir erhalten eine Liste von data.frames bzw. tibbles
map_list &lt;- csv_files %&gt;% 
  map(read_csv2,
      locale = locale(encoding = "latin1"),
      col_types = cols(.default = "c"))

class(map_list)
```

```
## [1] "list"
```

]
.panel[.panel-name[map_df (1)]

```r
# Ja Anteil nach Bezirk berechnen und alles in einen zusammenhängenden Datensatz schreiben
map_dataframe &lt;- map_list %&gt;% 
  map_df(~ .x %&gt;% 
           group_by(DATUM_ABSTIMMUNG,VORLAGE_BEZEICHNUNG,BEZIRK_NAME) %&gt;% 
           summarise(eing_stimmen = sum(as.numeric(EINGELEGTE_STIMMEN)),
                     ja = sum(as.numeric(JA_STIMMEN))) %&gt;% 
           mutate(ja_vote = ja/eing_stimmen))

class(map_dataframe)
```

```
## [1] "grouped_df" "tbl_df"     "tbl"        "data.frame"
```

]
.panel[.panel-name[map_df (2)]

```r
head(map_dataframe,5)
```

```
## # A tibble: 5 × 6
## # Groups:   DATUM_ABSTIMMUNG, VORLAGE_BEZEICHNUNG [1]
##   DATUM_ABSTIMMUNG VORLAGE_BEZEICHNUNG    BEZIRK_NAME eing_stimmen    ja ja_vote
##   &lt;chr&gt;            &lt;chr&gt;                  &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 16.05.2004       Gesetz zum Vollzug de… Arbon              10234  3938   0.385
## 2 16.05.2004       Gesetz zum Vollzug de… Bischofsze…         7496  2925   0.390
## 3 16.05.2004       Gesetz zum Vollzug de… Diessenhof…         1879   750   0.399
## 4 16.05.2004       Gesetz zum Vollzug de… Frauenfeld         12437  5431   0.437
## 5 16.05.2004       Gesetz zum Vollzug de… Kreuzlingen         8981  3621   0.403
```

]
.panel[.panel-name[map_chr]
- bei `map_chr` muss das Ergebnis der Funktion innerhalb von `map_chr` immer die Länge `1` haben. Sonst kann kein Vektor erstellt werden

```r
# Namen der einzelnen Vorlagen extrahieren als vektor
map_character &lt;- map_list %&gt;% 
  map_chr(~ .x[["VORLAGE_BEZEICHNUNG"]] %&gt;% unique())

map_character[c(1:4)]
```

```
## [1] "Gesetz zum Vollzug der Bundesgesetzgebung über den Erwerb von Grundstücken durch Personen im Ausland"                                   
## [2] "Beschulss des Grossen Rates über das Kreditbegehren von 28.2 Mio. Franken für den Erweiterungsbau des Berufsbildungszentrums Weinfelden"
## [3] "Beschluss des Grossen Rates über das Kreditbegehren von 11'950'000 Franken für den Neubau des Verwaltungsgebäudes II in Frauenfeld"     
## [4] "Beschluss des Grossen Rates betreffend Erweiterung des Strassennetzes durch eine neue Kantonsstrasse (\"Südumfahrung Kreuzlinge\")"
```
]
.panel[.panel-name[map_dbl]
- bei `map_dbl` muss das Ergebnis der Funktion innerhalb von `map_dbl` immer ein einzelner `double` (Fliesskommazahl oder Integer) sein.

```r
# Gesamtanzahl der Stimmberechtigten bei den jeweiligen Abstimmungen
map_double &lt;- map_list %&gt;% 
  map_dbl(~ sum(as.numeric(.x$STIMMBERECHTIGTE)))

map_double
```

```
##  [1] 145312 145946 146648 147242 147242 148022 148022 148474 148474 151082
## [11] 151082 152610 153000 153477 153477 154304 154304 154785 155001 156757
## [21] 156757 156757 157174 157174 157174 157174 157174 157917 159165 159907
## [31] 159907 165730 166492 166796
```
]
]
---
----
## purrr: Weitere nützliche Funktionen

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- `purrr` beinhaltet noch einige weitere nützliche Funktionen, vor allem im Umgang mit `Listen`

.panelset[
.panel[.panel-name[keep]
`keep` behält nur die Elemente, die eine bestimmte Bedingung erfüllen 

```r
# Abstimmungen mit im Schnitt mehr als 50% Stimmbeteiligung pro gGemeinde
hohe_beteiligung &lt;- map_list %&gt;% 
  keep(~{mean(as.numeric(.x[["STIMMBETEILIGUNG"]]))&gt;50})
length(map_list)
```

```
## [1] 34
```

```r
length(hohe_beteiligung)
```

```
## [1] 6
```
]
.panel[.panel-name[discard]
`discard` bildet das gegenstück zu `keep`

```r
# Abstimmungen mit im Schnitt 50% oder weniger Stimmbeteiligung pro Gemeinde
niedrige_beteiligung &lt;- map_list %&gt;% 
  discard(~{mean(as.numeric(.x[["STIMMBETEILIGUNG"]]))&gt;50})
length(hohe_beteiligung)
```

```
## [1] 6
```

```r
length(niedrige_beteiligung)
```

```
## [1] 28
```

]
.panel[.panel-name[every]
Trifft Bedingung auf **jedes** Element der Liste zu?

```r
# Ist die durchschnittliche Stimmbeteilung in den Gemeinden immer über 30%?
map_list %&gt;% 
  some(~{mean(as.numeric(.x[["STIMMBETEILIGUNG"]]))&gt;30})
```

```
## [1] TRUE
```

]
.panel[.panel-name[some]
Trifft Bedingung auf **mindestens ein** Element der Liste zu?

```r
# Gibt es Abstimmungen mit durchschnittlicher Stimmbeteilung in den Gemeinden von über 70%?
map_list %&gt;% 
  some(~{mean(as.numeric(.x[["STIMMBETEILIGUNG"]]))&gt;70})
```

```
## [1] FALSE
```
]
]

---
----
## purrr: Weitere nützliche Funktionen

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- `purrr` beinhaltet noch einige weitere nützliche Funktionen, vor allem im Umgang mit `Listen`

.panelset[
.panel[.panel-name[pluck (1)]
`pluck` hilft dabei auf Elemente in einer Liste zuzugreifen. Besonders hilfreich ist dies wenn Listen stark verschachtelt sind

```r
nested_list &lt;-
  list(
    a = list(1, 2, 3),
    b = list(b1 = c("a","b"), 
             b2 = TRUE),
    c = list(c1 = list(c1_1 = c(1, 2, 3, 4), 
                       c1_2 = c("h", "i", "j")
    ))
  )
```
]
.panel[.panel-name[pluck (2)]
Es kann Ebene für Ebene das Element nach Namen ausgewählt werden

```r
nested_list %&gt;% 
  pluck("b","b1")
```

```
## [1] "a" "b"
```

```r
# Gleich wie nested_list[["b"]][["b1"]]
```
]
.panel[.panel-name[pluck (3)]
Ebenso können auch die Indizes der einzelnen Listen verwendet werden

```r
nested_list %&gt;% 
  pluck(2,1)
```

```
## [1] "a" "b"
```

```r
# Gleich wie nested_list[[2]][[1]]
```
]
.panel[.panel-name[pluck (4)]
Wenn ein Element nicht existiert, wird kein `Error`, sondern `NULL` zurückgegeben (Vorteil wenn man es z.B. in Funktionen verwendet)

```r
nested_list %&gt;% 
  pluck(2,1)
```

```
## [1] "a" "b"
```

```r
# Gleich wie nested_list[[2]][[1]]
```
]
.panel[.panel-name[pluck (5)]
Listen Werte können auch gesetzt werden

```r
#set
pluck(nested_list,2,1) &lt;- "test"
#get
nested_list %&gt;% 
  pluck(2,1) 
```

```
## [1] "test"
```
]
]

---
----

## Hands-On: purrr¨

**Aufgabe:**

Im Aufgaben-File befinden sich ein `apply`-Workflow und ein Workflow, der einen `for-loop` beinhaltet.
Betrachte deren Ergebnisse.
Konvertiere die beiden Workflows in eine Pipeline unter Verwendung der `map` Funktionen. Achte darauf die passenden `map` Funktionen zu verwenden und keine unnötigen Zusatzschritte zu unternehmen.


**Aufgabe:**

Gegeben ist die Liste `gr_data_bezirke`. Sie enthält Daten zu den Kandidatenstimmen bei den Grossratswahlen 2012-2020. Jedes der 15 Listenelmente stellt das Ergebnis eines Bezirks in einem bestimmten Jahr dar. 

Erstelle einen zusammenhängenden Datensatz, der den/die Kandidierende/n für jedes Jahr und jeden Bezirk mit den Meisten Stimmen enthält. Der Datensatz soll ausserdem den Bezirknamen und das Jahr enthalten, damit man das Ergebnis später nachvollzihen kann. Verwende die passende map Funktion.

Der Datensatz `meiste_stimmen_bezirk` enthält das Ergebnis

---
----
## Nice to know: purrr
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://purrr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://purrr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Weiterführende Informationen zum `purr` Package:

- [Blogbeitrag von Rebecca Barter](https://www.rebeccabarter.com/blog/2019-08-19_purrr)

- [Vergleich purrr vs. apply](https://jtr13.github.io/spring19/ss5593&amp;fq2150.html)

- [purrr-Tutorial auf R-bloggers](https://www.r-bloggers.com/2020/05/one-stop-tutorial-on-purrr-package-in-r/)

- [Blog von Fatih Emre Ozturk](https://medium.com/@ozturkfemre/purr-in-r-a-powerful-tool-for-iteration-d4eb6c0b2d20)

- [Das purrr-Cookbook von Statistik Dresden (deutsch)](https://jkruppa.github.io/programing-purrr-furrr.html#sec-purrr)









---























----
## Funktionen

Eigene Funktionen sind hilfreich, wenn Code immer wieder ausgeführt werden muss. Im Vergleich zu copy-paste von Code ergeben sich folgende Vorteile:

1. Lesbarer Code: Du kannst deinen Funktionen aussagekräftige Namen geben, sodass andere sofort wissen, was in der Funktion passiert.

2. Erleichtertes Korrigieren: Sollte sich etwas ändern musst du nicht jeden kopierten Codeblock einzeln bearbeiten sondern nur die Funktion einmalig.

3. Weniger Flüchtigkeitsfehler: veränderst du zum Beispiel bei einem Code Block die Vaiablenzuweisung bei der Kopie aber nicht, kann das zu Problemen führen. Diese entstehen mit Funktionen erst gar nicht



---
----

## Komponenten von Funktionen
.panelset[
.panel[.panel-name[formals]
- eine Liste von Argumenten, die an die Funktion übergeben werden
- jedes Argument hat einen Namen (hier `vektor`) und es kann ein Objekt (Wert, oder sogar Funktion zugewisen werden)

```r
durchschnitt &lt;- function(`vektor`){
  # Ein Kommentar, der den Body beschreibt
  temp &lt;- sum(vektor)/length(vektor)
  return(temp)
}
```

Mit der `formals()` Funktionen können die Argumente aufgerufen werden. mit `?durchschnitt` kann ausserdem die Dokumentation (sofern vorhanden) eingesehen werden. 

```r
formals(durchschnitt)
```

```
## $vektor
```
]
.panel[.panel-name[body (1)]
- der Code der in der Funktion ausgeführt wird und zwischen `{ }` steht

```r
durchschnitt &lt;- function(vektor)`{`
  # Ein Kommentar, der den Body beschreibt
  temp &lt;- sum(vektor)/length(vektor) #&lt;&lt;
  return(temp) #&lt;&lt;
 `}`
```
]
.panel[.panel-name[body (2)]
Mit `attr(funktionsname, "srcref")` können sowohl der Funktions-Body als auch Inline-Kommentare sichtbar gemacht werden.

```r
attr(durchschnitt, "srcref")
```

```
## function(`vektor`){
##   # Ein Kommentar, der den Body beschreibt
##   temp &lt;- sum(vektor)/length(vektor)
##   return(temp)
## }
```
Die `body()` Funktion zeigt nur den Body ohne Kommentare
]
.panel[.panel-name[environment]

]
]

---
----
## Funktionen: Wichtige Konzepte

.panelset[
.panel[.panel-name[Name Masking]
Namen, die innerhalb einer Funktion definiert werden, "maskieren" Namen, die ausserhalb derFunktion definiert wurden.

```r
x &lt;- 10
f1 &lt;- function() {
  x &lt;- 1
  return(x)
}
f1()
```

```
## [1] 1
```
Die Variable ausserhalb der Funktion bleibt unverändert. Gleichzeitig verwendet die Funktion, das `x` welches **innerhalb** der Funktion verwendet wird. Die Zuweisung ausserhalb der Funktion hat keinen Einfluss

]
.panel[.panel-name[Funktionen vs. Variablen]

Es kann zu Problemen kommen, wenn Funktionen und nicht Funktionen den gleichen Namen tragen.

Daher ist wichtig zu vermeiden, dass dieser Fall auftritt. Namen sollten jeweils nur für **ein** Objekt verwendet werden.

]
.panel[.panel-name[Dynamic Lookup]
Vorsicht ist geboten, wenn man eine Variable ausserhalb der Funktion definiert und diese dann in der Funktion verwendet.

```r
x &lt;- 10
f2 &lt;- function() {
  return(x)
}
f2()
```

```
## [1] 10
```

R sieht, schaut als erstes, ob die Variable `x` irgendwo in der Funktion definiert wurde. Da dies nicht der Fall ist schaut R als nächstes ausserhalb der Variable im Globalen Environment. Dort wird `x` in diesem Fall gefunden und zurückgegeben.

]
.panel[.panel-name["Neustart"]
Das Environment einer Funktion wird bei jeder Ausführung zurückgesetzt. Zuweisungen bleiben somit nur für einen Durchlauf bestehen.

```r
f3 &lt;- function() {
  if (!exists("a")) { 
    a &lt;- 1 
  }  else { 
      a &lt;- a + 1 
  }
  a
}
f3()
```

```
## [1] 1
```
]
]

---
----
## Funktionen: Wichtige Konzepte

.panelset[
.panel[.panel-name[Lazy Evaluation]
- `Lazy Evaluation` bedeutet im Falle von R Funktionen, dass Argumenete erst dann evaluiert werden, wenn sie wirklich aufgerufen werden.
- Wenn ein Argument in einer Funktion nie verwendet wird, entsteht auch keine Fehlermeldung
- Das bietet den Vorteil dass potentiell aufwändige Berechnungen nur dann ausgeführt werden, wenn diese wirklich benötigt werden

```r
f4 &lt;- function(y) {
  x &lt;- 1
  return(x)
}
f4()
```

```
## [1] 1
```
]
.panel[.panel-name[Default Argumente]
- Dank `Lazy Evaluation` können in Funktionen default Argumente mitgegeben werden
- Wenn kein expliziter Wert angegeben wird, verwendet die Funktion den default Wert
- Diese können jedoch auch einfach überschrieben werden

```r
f5 &lt;- function(y=10) {
  return(y)
}
f5()
```

```
## [1] 10
```

```r
f5(50)
```

```
## [1] 50
```
]
.panel[.panel-name[Mehr Informationen]

Ausführlichere Informationen und mehr Beispiele zu den Konzepten findet ihr in [Hadley Wickhams Buch "Advanced R"](https://adv-r.hadley.nz/functions.html#lexical-scoping)

]
]

---
----
## Funktionen: Wichtige Konzepte

1. Jedes Objekt, das innerhalb einer Funktion erzeugt wird (einschließlich der Argumente, die an die Funktion übergeben werden), wird entfernt, wenn ein Funktionsdurchlauf abgeschlossen ist.

2. Existiert ein Objekt nicht innerhalb der Funktion, sucht R nach einem Objekt außerhalb der Funktion.

3. Argumenete werden erst dann evaluiert, wenn sie wirklich aufgerufen werden (*Lazy Evaluation*)

4. In R-Funktionen ist es möglich den Argumenten default Werte zuzuweisen

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5.b[
Alles, was innerhalb einer Funktion verwendet werden muss, sollte als Argument übergeben werden. Alles, was von einer Funktion gespeichert werden muss, sollte zurückgegeben werden

]
 
---
----
## Funktionen erstellen

Eine Funktion wird mit dem `function()` Keyword definiert.

```r
durchschnitt &lt;- function(vektor){
  temp &lt;- sum(vektor)/length(vektor)
  return(temp)
}
wert &lt;- durchschnitt(c(5,6,2,7,8))
wert
```

```
## [1] 5.6
```
.panelset[
.panel[.panel-name[Name]
- `durchschnitt` ist in diesem Fall der Name der Funktion. Somit kann sie mit `durchschnitt()` aufgerufen werden
- wir haben die `anonymus functions` bereits kennen gelernt. Diese besitzen *keinen* Namen
]
.panel[.panel-name[Argumente]
Das einzige Argument dieser Funktion ist `vektor`. Eine Funktion kann unbegrenzt Argumente besitzen oder aber keines. 
]
.panel[.panel-name[Return]
Um das Ergebnis einer Funktion einer neuen Variable zuweisen zu können, wird ein `return` Statement verwendet.
]
]
---
----
## Return Value
Return bildet den Abschluss einer Funktion. Alles was nach einem `return()` Statement im Funktions-Body folgt, wird nicht mehr ausgeführt.
In R- Funktionen gibt es implizite als auch explizite `return` Statements.
.panelset[
.panel[.panel-name[Implizites Return]
Wenn kein `return()` definiert wird, wird der letzte **ausgegebene** Wert in der Funktion zurückgegben.

```r
f5 &lt;- function(y) {
  y
}
f5(20)
```

```
## [1] 20
```
]
.panel[.panel-name[Explizites Return]
Meiner Meinung nach empfiehlt es sich **immer** ein `return()` Statement zu verwenden, wenn ein Wert zurückgegeben werden soll. Dies macht den Code einfacher lesbar.

```r
f6 &lt;- function(y) {
  return(y)
}
f6(20)
```

```
## [1] 20
```
]
]

---
----
## Sprechende Funktionen

- der Sinn von Funktionen liegt unter anderem darin, den Code für Menschen einfacher verständlich zu machen.

- es ist daher sehr wichtig den eigenen Funktionen *sprechende* Namen zu geben

- idealerweise sind Namen kurz und klar, im Zweifel ist es aber wichtiger klar als kurz zu sein, da die RStudio-Autovervollständigung dabei hilft auch lange Namen einzugeben

- deutsche Funktionsnamen sind völlig okay, aber auf keinen Fall sollten Umlaute verwendet werden



---
----
## Funktionen: Best Practices

Best Practice laut [R for Data Science](https://r4ds.had.co.nz/functions.html#functions-are-for-humans-and-computers)
.panelset[
.panel[.panel-name[Verben/Nomen]
- generell sollten Funktionen Verben sein und Argumente Nomen
- Nomen sollten nur dann als Funktionsnamen verwendet werden, wenn das angedachte Verb zu "generisch" klingt (z.B. “get”, “compute”, “calculate” oder “determine”)

```r
# Zu kurzer Name
f()
# Weder ein Verb noch beschreibend
my_awesome_function()
# Lang aber klar
impute_missing()
collapse_years()
```
]
.panel[.panel-name[Mehrere Wörter]
- besteht ein Funktionsname aus mehreren Worten, empfiehlt sich die Trennung mit `_` (*snake_case*) 
- alternativ kann *camelCase* verwendet werden (erstes Wort klein, alle folgenden Worte mit grosse Anfangsbuchstaben)
- Wichtig ist **Konsistenz** (mische nicht *snake_case* und *camelCase*, wenn mehrere Funktionen erstellt werden)

```r
camelCaseFunction()

snake_case_function()
```
]
.panel[.panel-name[Kommentare]

- kommentiere innerhalb des Funktions-Body in dem du `#` verwendest

- beim Kommentieren gilt: Versuche zu beschreiben, **warum** du etwas tust und nicht **was** du tust.
.bg-light-gray.b--dark-gray.ba.bw2.br3.shadow-5.ph4.mt2[
Do you need to add some intermediate variables with useful names? Do you need to break out a subcomponent of a large function so you can name it? However, your code can never capture the reasoning behind your decisions: why did you choose this approach instead of an alternative? What else did you try that didn’t work? It’s a great idea to capture that sort of thinking in a comment.
.tr[
— Hadley Wickham, R for Data Science, Chapter 19.3
]
]
]
.panel[.panel-name[Argumente]

- Argumente sollten wie Funktionen selbst aussagekräftige Namen besitzen (generell Nomen)

- es gibt einige spezielle Argumente, für die sich eine einheitliche Benennung durchgesetzt hat. Diese findet ihr [hier](https://r4ds.had.co.nz/functions.html#choosing-names)

- ein guter Tipp ist es ausserdem, sich Argumente bestehender Funktionen anzusehen

]
]

---
----
## Funktionen: Conditions

Ein R Workflow (oder eine Funktion) kann unterbrochen werden, um einen speziellen Zustand (*condition*) zu siganlisieren.

In R gibt es generell drei `conditions`:

1. **Error:** Ein Fehler im Ablauf, der ein weiterlaufen verhindert -&gt; Der Prozess stopt an der Stelle, an der der Fehler aufgetreten ist.
2. **Warning:** Weist auf ein mögliches Problem hin, das das Programm nicht anhält, sondern den Benutzer warnt
3. **Info:** Gibt informatives Feedback über den laufenden Prozess, ohne einen Fehler oder eine Warnung zu implizieren


---
----
## Funktionen: Conditions

In Funktionen können eigene `conditions` erzeugt werden. Das ist wichtig, da es dem Benutzer später hilft herauszufinden, was er/sie womöglich falsch gemacht hat. 

.panelset[
.panel[.panel-name[stop]
Mit `stop()` kann ein *Error* erzeugt werden

```r
f7 &lt;- function(x){
  if (!is.numeric(x)){
    stop(paste0("Der Wert für x (",x,") ist nicht numerisch."))
  }
  return(x*7)
}
f7("2")
```

```
## Error in f7("2"): Der Wert für x (2) ist nicht numerisch.
```
]
.panel[.panel-name[warning]
Mit `warning()` kann eine *Warning Message* erzeugt werden


```r
f7 &lt;- function(x){
  if (!is.numeric(x)){
    x &lt;- as.numeric(x)
    warning("x wurde zu numeric konvertiert")
  }
  return(x*7)
}
f7("2")
```

```
## Warning in f7("2"): x wurde zu numeric konvertiert
```

```
## [1] 14
```
]
.panel[.panel-name[message]
`message()` erzeugt eine `Info Message` 

```r
f8 &lt;- function(x){
  if (is.numeric(x)){
    message("x ist ein numerischer Wert")
  }
  return(x*7)
}
f8(2)
```

```
## x ist ein numerischer Wert
```

```
## [1] 14
```
]
]


---
----

## Hands-On: Funktionen

1. Schreibe eine eigene Funktion zur Berechnung der Varianz eines numerischen Vektors und nenne sie `varianz`
`$$\mathrm{Var}(x) = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2$$`
**Erklärung:**
- `\(n\)` ist die Stichprobengrösse (-&gt; die Anzahl der Elemente im Vektor)
- `\(x_i\)` ist der Wert von Vektor `\(x\)` an Stelle `\(i\)`
- `\(\bar{x}\)` ist der Mittelwert von Vektor `\(x\)`
- `\(\sum_{i=1}^n (x_i - \bar{x}) ^2\)` bedeuted das alle Ergebnisse von `\((x_i - \bar{x}) ^2\)` für jedes Element im vektor aufsummiert werden.
---



























----
## ggplot2: Daten visualisieren

&lt;figure class="logo-fig logo-title1"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title2"&gt;
  &lt;a href='https://readxl.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readxl.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title3"&gt;
  &lt;a href='https://haven.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://haven.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title4"&gt;
  &lt;a href='https://dplyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://dplyr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title5"&gt;
  &lt;a href='https://tidyr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://tidyr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title6"&gt;
  &lt;a href='https://stringr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://stringr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title7"&gt;
  &lt;a href='https://lubridate.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://lubridate.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title8"&gt;
  &lt;a href='https://magrittr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://magrittr.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

&lt;figure class="logo-fig logo-title9"&gt;
  &lt;a href='https://forcats.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://forcats.tidyverse.org/logo.png' class='logo' style ="opacity: 0.5;"/&gt;
  &lt;/a&gt;
&lt;/figure&gt;


&lt;figure class="logo-fig logo-title10"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo' /&gt;
  &lt;/a&gt;
&lt;/figure&gt;




---
----
## ggplot2: Daten visualisieren
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

- ggplot2 bietet eine einfache Möglichkeit, datenbasierte Grafiken zu erstellen, ohne komplizierte Grafikbefehle schreiben zu müssen

- ggplot2 verwendet das Grammar of Graphics-Konzept, das auf einfache Syntax und klare Struktur setzt.

- durch Hinzufügen von Ebenen (Layers) können Grafiken angepasst werden

- das Buch [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/toolbox.html) bietet umfangreiche Informationen

---
----
## ggplot2: Vom Datensatz zur Grafik
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
.panelset[
.panel[.panel-name[Beschreibung]
Eine Grafik in ggplot2 wird immer über den `ggplot()` Befehl initialisiert und besteht aus drei Grundbestandteilen
- **data:** ein Datenobjekt, auf werlches sich die Grafik bezieht
- **aesthetic mappings:** Datenvariablen werden bestimmten ästhetischen Eigenschaften zugeordnet, wie z.B. Farbe, Größe, Form, Position, etc.
- **geom:** in welcher Form die Daten visualisiert werden sollen (z.B. Scatter, Linien, Balken, etc.)

]
.panel[.panel-name[Code]


```r
library(ggplot2)
set.seed(1234)
index &lt;- sample(1:nrow(geburten),2000)
geburten_sample &lt;- geburten[index,]

ggplot(data = geburten_sample, aes(x=age_v, y=age_m))+
  geom_point()
```
]
.panel[.panel-name[Grafik]
Alter des Vaters auf der x-Achse und Alter der Mutter auf der y-Achses

&lt;img src="index_files/figure-html/unnamed-chunk-475-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
]

---
----
## ggplot2: Aesthetic Mappings
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
.panelset[
.panel[.panel-name[Beschreibung]
- Mit **aesthetic mappings** können Datenvariablen  bestimmten ästhetischen Eigenschaften, wie z.B. Farbe, Größe, Form, Position, etc. zugeordnet werden.
- sie werden innerhalb des `aes()` Befehls definiert
- `aes()` kann sowohl für die ganze Grafik innerhalb des `ggplot()` Befehls verwendet werden oder aber für jeden Layer seperat.
- aesthetics können auch ausserhalb von `aes()` definiert werde, wenn kein Variablenbezug nötig ist 
- beim mapping spielt auch der Datentyp eine wichtige Rolle

&lt;p&gt;Eine Übersicht über mögliche aesthetics findet ihr z.B. &lt;a href = 'https://ggplot2.tidyverse.org/articles/ggplot2-specs.html'&gt;hier&lt;/a&gt;&lt;/p&gt;

]
.panel[.panel-name[Bsp 1]
Die Datenpunkte sollen je nach Geschlecht (`sex`) unterschiedlich eingefärbt werden

```r
ggplot(data = geburten_sample, aes(x=age_v, y=age_m, color = sex))+
  geom_point()
```
]
.panel[.panel-name[Fig 1]
&lt;img src="index_files/figure-html/unnamed-chunk-477-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
.panel[.panel-name[Bsp 2]
`sex` wird als numerische Variable erkannt weshalb eine Umwandlung nötig ist

```r
ggplot(data = geburten_sample, aes(x=age_v, y=age_m, color = as.factor(sex)))+
  geom_point()
```
]
.panel[.panel-name[Fig 2]
&lt;img src="index_files/figure-html/unnamed-chunk-479-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
.panel[.panel-name[Bsp 3]
Ausserhalb des `aes()` Befehls können auch statische Variablen als aesthetics definiert werden (siehe [hier](https://ggplot2-book.org/layers.html#setting-mapping))

```r
ggplot(data = geburten_sample, aes(x=age_v, y=age_m, color = as.factor(sex)))+
  geom_point(shape = 15)
```
]
.panel[.panel-name[Fig 3]
&lt;img src="index_files/figure-html/unnamed-chunk-481-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
]

---
----

## ggplot2: geoms
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
.panelset[
.panel[.panel-name[Beschreibung]
- **geoms** definieren die Form in der Daten dargestellt werden
- jedes geom ist zweidimensional und benötigt daher `x` und `y` aestheics, um die Position festzulegen
- jedem geom können die aesthetics `color` und `size` zugeordnet werden
- ausserdem gibt es geom-spezifische aesthetics (z.b. `linetype` für `geom_line()`)


&lt;p&gt;Eine Übersicht über verfügbare geoms findet ihr z.B. &lt;a href = 'https://ggplot2.tidyverse.org/reference/#geoms'&gt;hier&lt;/a&gt;&lt;/p&gt;

]
.panel[.panel-name[Bsp]
- Die Grafik leidet bisher unter *overplotting* (= mehrere Datenpunkte liegen direkt übereinander)
- Mit `geom_jitter` anstelle von `geom_point` kann eine minimale künstliche Varianz erzeugt werden, welche die Grafik aussagekräftiger macht

```r
ggplot(data = geburten_sample, aes(x=age_v, y=age_m, color = as.factor(sex)))+
  geom_jitter(shape = 15)
```
]
.panel[.panel-name[Fig]
&lt;img src="index_files/figure-html/unnamed-chunk-483-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
]


---
----

## ggplot2: geoms (Beispiele)
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
.panelset[
.panel[.panel-name[Bsp 1]
- Balkendiagramm des Altersunterschied zwischen Vätern und Müttern über Zeit
- Pipeline enthält sowohl Datenaufbereitung als auch -visualisierung (nicht immer empfehlenswert)

```r
geburten %&gt;% 
  mutate(age_diff = age_v-age_m) %&gt;% 
  group_by(stat_jahr) %&gt;% 
  summarise(mean_dif =mean(age_diff,na.rm = T)) %&gt;% 
  ggplot(aes(x= stat_jahr,y=mean_dif)) + 
  geom_bar(stat = "identity")
```


]
.panel[.panel-name[Fig 1]
&lt;img src="index_files/figure-html/unnamed-chunk-485-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
.panel[.panel-name[Bsp 2]
- Hinzufügen einer Linie als zusätzlicher Layer

```r
geburten %&gt;% 
  mutate(age_diff = age_v-age_m) %&gt;% 
  group_by(stat_jahr) %&gt;% 
  summarise(mean_dif =mean(age_diff,na.rm = T)) %&gt;% 
  ggplot(aes(x= stat_jahr,y=mean_dif)) + 
  geom_bar(stat = "identity") +
  geom_line(linetype = "dashed", color = "red")
```
]
.panel[.panel-name[Fig 2]
&lt;img src="index_files/figure-html/unnamed-chunk-487-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
.panel[.panel-name[Bsp 3]
- Durchschnittliches Alter der Mutter und des Vaters bei Geburt
- Mehrere Linien mit unterscheidlichen Positionen

```r
geburten %&gt;% 
  group_by(stat_jahr) %&gt;% 
  summarise(mean_m =mean(age_m,na.rm = T), #Durchschnittliches Alter der Mutter
            mean_v = mean(age_v,na.rm = T)) %&gt;% #Durchschnittliches Alter des Vaters
  ggplot(aes(x= stat_jahr)) + 
  geom_line(aes(y=mean_v), color = "red") +
  geom_line(aes(y=mean_m), color = "blue")
```
]
.panel[.panel-name[Fig 3]
&lt;img src="index_files/figure-html/unnamed-chunk-489-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
.panel[.panel-name[Bsp 4]
- Ermittlung von Missing Values

```r
geburten %&gt;% 
  group_by(stat_jahr) %&gt;% 
  summarise(age_m_na =sum(is.na(age_m))/n(), #Anteil NAs beim Alter der Mutter
            age_v_na =sum(is.na(age_v))/n()) %&gt;% #Anteil NAs beim Alter des Vaters
  ggplot(aes(x= stat_jahr)) + 
  geom_line(aes(y=age_v_na), color = "red") +
  geom_line(aes(y=age_m_na), color = "blue")
```
]
.panel[.panel-name[Fig 3]
&lt;img src="index_files/figure-html/unnamed-chunk-491-1.png" style="display: block; margin: auto auto auto 0;" /&gt;
]
]


---
----
## Beispiel: Parteistärke



---
----

## Hands-On: Daten visualisieren mit ggplot2

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

Stelle das erreichte Alter von Männern und Frauen im Zeitverlauf gegenüber.

- Schaue dir den vorbereiten Datensatz `heirat_mod` an, bevor du die Visualisierung angehst 
- Erzeuge ein Liniendiagramm, welches die Altersentwicklung von Männern und Frauen bei der Hochzeit abbildet
- Das Liniendiagramm soll eine Linie pro Geschlecht enthalten. Beide Linien sollen unterschiedliche Farben haben.   
- Füge einen Titel sowie eine Beschriftung für X- und Y-Achse hinzu.
- Verwende dafür die labs() Funktion (`?ggplot2::labs()` für Hilfe)

<div class="countdown" id="timer_d0e01bc0" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
----

## ggplot2: Good to know
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ggplot2.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://ggplot2.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
Ein vertieftes Einsteigen in die Feinheiten von `ggplot2` sprengt den Rahmen dieses Workshops.&lt;br&gt;&lt;br&gt;
Daher sei noch einmal auf das Buch [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/) verwiesen. Hier ist besonders das Kapitel [Build a plot layer by layer](https://ggplot2-book.org/layers.html#layers) interessant, welches die notwendigen Schritte zur Erstellung von Grafiken erläutert. Daebi wird auch auf das Styling einer Grafik eingegangen. &lt;br&gt;
&lt;br&gt;
Mit dem [plotly](https://plotly-r.com/) Package ist es ausserdem möglich statische Grafiken in interaktive Grafiken zu transformieren

---




















----

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## Einlesen von CSV-Dateien


- CSV-Dateien sind ein häufiges Format für Datenaustausch.
- Typische Probleme beim Einlesen:
  - **Kodierung** (z.B. `UTF-8`, `latin1`, Umlaute).
  - Unterschiedliche **Trennzeichen** (z.B. `,`, `;`, `\t`).
  - **Unklare Struktur** (fehlende Header, unregelmäßige Daten).

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen

**Problem:** 
- Falsche Darstellung von Zeichen wie Umlauten (`ä`, `ö`, `ü`)
- Unterschiedliche Trennzeichen (z.B. `,`, `;`, `\t`)

**Grund:**
- Das Encoding beim einlesen ist nicht korrekt gesetzt. Oft ensteht dies, wenn csv Dateien direkt aus Excel heraus erstellt werden. Diese csv-Dateien sind dann oft in `latin1` und nicht im Standardformat `utf-8` kodiert.
- Beim Export aus Excel wird in der Regel ein Semikolon (`;`) anstelle des üblichen Kommas (`,`) als Trennezichen gesetzt

**Lösung:**
Encoding und Trennzeichen können manuell eingestellt werden

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Exkurs: Encoding

.panelset[
.panel[.panel-name[Idee]

- Encoding übersetzt Zeichen in Zahlen (Bytes), die der Computer speichern und verarbeiten kann.

- Verschiedene Encodings nutzen unterschiedliche Zahlenfolgen, um dasselbe Zeichen darzustellen.

- Verschiedene Encodings liegen unterschieldliche Lookup Tabellen zu Grunde aus denen das jeweils dargestellte Zeichen mit dem entsrechenden Code entnommen wird
]
.panel[.panel-name[Encodingvarianten]


  - **ASCII**: Basis-Lookup-Tabelle (nur englische Buchstaben, Zahlen, Symbole).
    - `A` = `65`, `B` = `66`.
  - **latin1** (ISO-8859-1): Erweiterung von ASCII, unterstützt europäische Sonderzeichen.
    - `ä` = `0xE4`.
  - **UTF-8**: Modernes Unicode-Encoding, speichert Zeichen mit 1-4 Bytes.
    - `ä` = `0xC3 0xA4`.
  - **UTF-16**: Unicode mit 2 Bytes für viele Zeichen.
    - `ä` = `0x00E4`.

]
.panel[.panel-name[Beispiel]
  
**Speichern das Wort `München` in einer Datei:**
- Bytes in **UTF-8**: `0x4D 0xC3 0xBC 0x6E 0x63 0x68 0x65 0x6E`.
- Bytes in **latin1**: `0x4D 0xFC 0x6E 0x63 0x68 0x65 0x6E`.

Wird die Datei mit falschem Encoding gelesen:
  - **UTF-8** gelesen als latin1: `MÃ¼nchen` statt `München`.
]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Ausgangsdaten

.panelset[
.panel[.panel-name[Variante 1]

**UTF-8 und Komma als Trennzeichen**

- Umlaute werden in Excel nicht korrekt angezeigt
- Excel hat Probleme damit CSVs anzuzeigen, die in `utf-8` kodiert sind

![CSV Variante 1](img/csv_v1.png)
]
.panel[.panel-name[Variante 2]

**latin1 und Komma als Trennzeichen**

- Trennzeichen wird nicht korrekt interpretiert

![CSV Variante 2](img/csv_v2.png)
]
.panel[.panel-name[Variante 3]

**UTF-8 und Semikolon als Trennzeichen**

- Umlaute werden in Excel nicht korrekt angezeigt

![CSV Variante 3](img/csv_v3.png)
]
.panel[.panel-name[Variante 4]

**latin1-8 und Semikolon als Trennzeichen**

- korrekte Darstellung

![CSV Variante 4](img/csv_v4.png)
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Daten einlesen

.panelset[
.panel[.panel-name[Variante 1]

**UTF-8 und Komma als Trennzeichen**


```r
library(readr)
csv_v1 &lt;- read_csv("Daten/geb_csv1.csv")
```

```
## Rows: 4 Columns: 5
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr (3): id, name, gemeinde_m
## dbl (2): stat_jahr, geb_year
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```
]
.panel[.panel-name[Variante 2]

**latin1 und Komma als Trennzeichen**


```r
library(readr)
csv_v2 &lt;- read_csv("Daten/geb_csv2.csv")
```

```
## Rows: 4 Columns: 1
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr (1): stat_jahr,"id","geb_year","name","gemeinde_m"
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```
]
.panel[.panel-name[Variante 3]

**UTF-8 und Semikolon als Trennzeichen**


```r
library(readr)
csv_v3 &lt;- read_csv("Daten/geb_csv3.csv")
```

```
## Rows: 5 Columns: 1
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr (1): stat_jahr;id;geb_year;name;gemeinde_m
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```
]
.panel[.panel-name[Variante 4]

**latin1-8 und Semikolon als Trennzeichen**


```r
library(readr)
csv_v4 &lt;- read_csv("Daten/geb_csv4.csv")
```

```
## Rows: 7 Columns: 1
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr (1): stat_jahr;id;geb_year;name;gemeinde_m
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```
]
]



---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Daten anschauen

.panelset[
.panel[.panel-name[Variante 1]

**UTF-8 und Komma als Trennzeichen**


```r
head(csv_v1,3)
```

```
## # A tibble: 3 × 5
##   stat_jahr id    geb_year name        gemeinde_m
##       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;     
## 1      2016 x         2016 Amélie Lea  x         
## 2      2005 x         2005 Joséphine   x         
## 3      2010 x         2010 Lara Bärbel x
```
]
.panel[.panel-name[Variante 2]

**latin1 und Komma als Trennzeichen**


```r
head(csv_v2,3)
```

```
## # A tibble: 3 × 1
##   `stat_jahr,"id","geb_year","name","gemeinde_m"`
##   &lt;chr&gt;                                          
## 1 "2016,x,2016,\"Am\xe9lie Lea\",x"              
## 2 "2005,x,2005,\"Jos\xe9phine\",x"               
## 3 "2010,x,2010,\"Lara B\xe4rbel\",x"
```
]
.panel[.panel-name[Variante 3]

**UTF-8 und Semikolon als Trennzeichen**


```r
head(csv_v3,3)
```

```
## # A tibble: 3 × 1
##   `stat_jahr;id;geb_year;name;gemeinde_m`
##   &lt;chr&gt;                                  
## 1 2016;x;2016;Amélie Lea;x               
## 2 2005;x;2005;Joséphine;x                
## 3 2010;x;2010;Lara Bärbel;x
```
]
.panel[.panel-name[Variante 4]

**latin1-8 und Semikolon als Trennzeichen**


```r
head(csv_v4,3)
```

```
## # A tibble: 3 × 1
##   `stat_jahr;id;geb_year;name;gemeinde_m`
##   &lt;chr&gt;                                  
## 1 "2016;x;2016;Am\xe9lie Lea;x"          
## 2 "2005;x;2005;Jos\xe9phine;x"           
## 3 "2010;x;2010;Lara B\xe4rbel;x"
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Einleseprozess korrigieren

.panelset[
.panel[.panel-name[Variante 1]

**UTF-8 und Komma als Trennzeichen**
- keine Anpassung nötig, da Daten bereits korrekt eingelesen sind


```r
csv_v1 &lt;- read_csv("Daten/geb_csv1.csv",show_col_types = FALSE)
head(csv_v1,3)
```

```
## # A tibble: 3 × 5
##   stat_jahr id    geb_year name        gemeinde_m
##       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;     
## 1      2016 x         2016 Amélie Lea  x         
## 2      2005 x         2005 Joséphine   x         
## 3      2010 x         2010 Lara Bärbel x
```
]
.panel[.panel-name[Variante 2]

**latin1 und Komma als Trennzeichen**
- Anpassung des Encodings mithilfe der `locale()` Funktion


```r
csv_v2 &lt;- read_csv("Daten/geb_csv2.csv", locale = locale(encoding = "latin1"),show_col_types = FALSE)
head(csv_v2,3)
```

```
## # A tibble: 3 × 1
##   `stat_jahr,"id","geb_year","name","gemeinde_m"`
##   &lt;chr&gt;                                          
## 1 "2016,x,2016,\"Amélie Lea\",x"                 
## 2 "2005,x,2005,\"Joséphine\",x"                  
## 3 "2010,x,2010,\"Lara Bärbel\",x"
```
]
.panel[.panel-name[Variante 3]

**UTF-8 und Semikolon als Trennzeichen**
- Anpassung des Trennzeichens.
- `read_delim` ist die Basisfunktion für alle `read_`-Funktionen. Hier können sämtliche Optionen selbst definiert werden


```r
csv_v3 &lt;- read_delim("Daten/geb_csv3.csv", delim = ";",show_col_types = FALSE)
head(csv_v3,3)
```

```
## # A tibble: 3 × 5
##   stat_jahr id    geb_year name        gemeinde_m
##       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;     
## 1      2016 x         2016 Amélie Lea  x         
## 2      2005 x         2005 Joséphine   x         
## 3      2010 x         2010 Lara Bärbel x
```
]
.panel[.panel-name[Variante 4]

**latin1-8 und Semikolon als Trennzeichen**
- Anpassung des Trennzeichens und des Encodings.


```r
csv_v4 &lt;- read_delim("Daten/geb_csv4.csv", delim = ";",locale = locale(encoding = "latin1"),show_col_types = FALSE)
head(csv_v4,3)
```

```
## # A tibble: 3 × 5
##   stat_jahr id    geb_year name        gemeinde_m
##       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;     
## 1      2016 x         2016 Amélie Lea  x         
## 2      2005 x         2005 Joséphine   x         
## 3      2010 x         2010 Lara Bärbel x
```
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Zu beachten

- Das Encoding sollte nach dem Einlesen direkt überprüft werden.

- Problematisch wird es dann, wenn falsch kodierte Daten erneut in anderer Kodierung abgespeichert werden. In diesem Fall kann das Encoding beim Einlesen nicht mehr ohne weiteres geändert werden, da die falsch kodierten Zeichen dann als tatsächlich interpretierte Zeichen interpretiert werden.

- Beim Abspeichern gibt R allerdings bereits eine Warnmeldung aus 





---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: Zu beachten

.panelset[
.panel[.panel-name[Einlesen mit falscher Kodierung]

- in `latin1` kodierte Daten ohne Umwandlung als `utf-8` abspeichern


```r
csv_v2 &lt;- read_csv("Daten/geb_csv2.csv",show_col_types = FALSE)
write.csv(csv_v2,"Daten/geb_csv2_falsch.csv",fileEncoding = "utf-8",row.names = F)
```

```
## Warning in utils::write.table(csv_v2, "Daten/geb_csv2_falsch.csv", fileEncoding
## = "utf-8", : invalid char string in output conversion

## Warning in utils::write.table(csv_v2, "Daten/geb_csv2_falsch.csv", fileEncoding
## = "utf-8", : invalid char string in output conversion

## Warning in utils::write.table(csv_v2, "Daten/geb_csv2_falsch.csv", fileEncoding
## = "utf-8", : invalid char string in output conversion

## Warning in utils::write.table(csv_v2, "Daten/geb_csv2_falsch.csv", fileEncoding
## = "utf-8", : invalid char string in output conversion
```
]
.panel[.panel-name[Einlesen (1)]

- Einlesen im beim Zwischenspeichern definierten `utf-8` 


```r
csv_v2_falsch &lt;- read_csv("Daten/geb_csv2_falsch.csv",show_col_types = FALSE)
```

```
## Warning: One or more parsing issues, call `problems()` on your data frame for details,
## e.g.:
##   dat &lt;- vroom(...)
##   problems(dat)
```

```r
head(csv_v2_falsch,3)
```

```
## # A tibble: 2 × 1
##   `stat_jahr,"id","geb_year","name","gemeinde_m"`
##   &lt;chr&gt;                                          
## 1 "2016,x,2016,\"Am\n2005,x,2005,\"Jos"          
## 2 "2010,x,2010,\"Lara B\n1999,x,1999,\"Seval K"
```
]
.panel[.panel-name[Einlesen (2)]

- Einlesen im ursprünglich richtigen `latin1`
- Daten sind falsch abgelegt. Das Ändern des Encodings hat nun keine Auswirkung mehr


```r
csv_v2_falsch &lt;- read_csv("Daten/geb_csv2_falsch.csv",locale = locale(encoding = "latin1"),show_col_types = FALSE)
```

```
## Warning: One or more parsing issues, call `problems()` on your data frame for details,
## e.g.:
##   dat &lt;- vroom(...)
##   problems(dat)
```

```r
head(csv_v2_falsch,3)
```

```
## # A tibble: 2 × 1
##   `stat_jahr,"id","geb_year","name","gemeinde_m"`
##   &lt;chr&gt;                                          
## 1 "2016,x,2016,\"Am\n2005,x,2005,\"Jos"          
## 2 "2010,x,2010,\"Lara B\n1999,x,1999,\"Seval K"
```
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: SONDERFÄLLE

- in der Regel reicht es, zwischen `utf-8` und `latin-1` zu wählen, da so die meisten Fälle abgedeckt werden

- SAS exportiert csv Dateien per Default im `Windows-1512`-Encoding, da das default Encoding vom Betriebssystem und der Konfiguration der SAS-Sitzung abhängt. Dieses Encoding basiert zwar auf `latin1`, enthält aber zusätzlich weitere Zeichen aus westlichen Sprachen.

- Ein Problem ergibt sich zum Beispiel, wenn der **Halbgeviertstrich (–)** (nicht zu verwechseln mit dem Bindestrich (-)) verwendet wird. Dieser existiert nicht in der `latin1` Kodierungstabelle und wird daher falsch interpretiert 

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Kodierung und Trennzeichen: SONDERFÄLLE


.panelset[
.panel[.panel-name[Einlesen in utf-8]



```r
csv_sas &lt;- read_delim("Daten/1_Sozialhilfequote_Bezüger_Dossiers_Gde_2023.csv",delim = ";",show_col_types = F)
csv_sas |&gt; slice(42) |&gt; select(GdenameTG,Quote_Kategorie)
```

```
## # A tibble: 1 × 2
##   GdenameTG                Quote_Kategorie   
##   &lt;chr&gt;                    &lt;chr&gt;             
## 1 "Kradolf-Sch\xf6nenberg" "Quote 1,0\x961,9"
```
]
.panel[.panel-name[Einlesen mit latin1]



```r
csv_sas_lat &lt;- read_delim("Daten/1_Sozialhilfequote_Bezüger_Dossiers_Gde_2023.csv",delim = ";",locale = locale(encoding = "latin1"),show_col_types = F)
csv_sas_lat |&gt; slice(42) |&gt; select(GdenameTG,Quote_Kategorie)
```

```
## # A tibble: 1 × 2
##   GdenameTG           Quote_Kategorie     
##   &lt;chr&gt;               &lt;chr&gt;               
## 1 Kradolf-Schönenberg "Quote 1,0\u00961,9"
```
]
.panel[.panel-name[Einlesen mit Windows-1252]



```r
csv_sas_win &lt;- read_delim("Daten/1_Sozialhilfequote_Bezüger_Dossiers_Gde_2023.csv",delim = ";",locale = locale(encoding = "Windows-1252"),show_col_types = F)
csv_sas_win |&gt; slice(42) |&gt; select(GdenameTG,Quote_Kategorie)
```

```
## # A tibble: 1 × 2
##   GdenameTG           Quote_Kategorie
##   &lt;chr&gt;               &lt;chr&gt;          
## 1 Kradolf-Schönenberg Quote 1,0–1,9
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Daten Zwischenspeichern

- in R sollten Zwischenspeihcerungen die nur in R weiterverwendet werden sollen **IMMER** im RDS-Format abgespeichert werden.

- Dieses R-eigene Format ist speichereffizient und speichert alle R-Objekte genau so wie sie sind

- Wenn csv geladen wird, sollte `readr::read_csv()` anstatt von `read.csv()` benutzt werden, da es besonders bei grossen Datensätzen (&gt;100MB) ca. 5 mal schneller ist.

- Weiterführende Infos zum effizienten einlesen [hier](https://bookdown.org/csgillespie/efficientR/input-output.html)
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://readr.tidyverse.org' target="_blank"&gt;
    &lt;img src='https://readr.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Daten Zwischenspeichern

![](index_files/figure-html/unnamed-chunk-534-1.png)&lt;!-- --&gt;
---





















----

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ycphs.github.io/openxlsx/' target="_blank"&gt;
    &lt;img src='https://i2.wp.com/mfatihtuzen.netlify.app/posts/2024-11-04_openxlsx/openxlsx.png?w=578&amp;ssl=1' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;



## Einführung in `openxlsx`

- Leichtgewichtiges R-Package für Excel-Dateien

- Lesen, Schreiben und Formatieren von `.xlsx`-Dateien

- Keine externe Software (z. B. Excel) erforderlich.

- basiert auf sog. `workbook` objekten

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ycphs.github.io/openxlsx/' target="_blank"&gt;
    &lt;img src='https://i2.wp.com/mfatihtuzen.netlify.app/posts/2024-11-04_openxlsx/openxlsx.png?w=578&amp;ssl=1' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## openxlsx: Sheets erstellen und Daten eintragen

.panelset[
.panel[.panel-name[Erklärung]

- ein `workbook` kann entweder mit `createWorkbook()` neu erstellt werden oder eine `xlsx`-Datei kann mit `loadWorkbook()` zum bearbeiten eingelesen werden

- Neue Reiter werden mit `addWorksheet()` angefügt. Bei neuen Workbooks muss dies immer als erstes erledigt werden, da es sonst keine Reiter gibt. Mit `removeWorksheet()` kann ein Worksheet wieder entfernt werden.

- mit `writeData()` werden Daten eingetragen. Hier besteht die Möglichkeit genau zu definieren, wo die Daten eingefügt werden sollen
]
.panel[.panel-name[Code]

```r
library(openxlsx)

# Workbook neu erstellen
wb &lt;- createWorkbook()

# Neues Worksheet erstellen
addWorksheet(wb,sheetName = "Neuer Reiter")

# Daten eintragen ins entsprechenden sheet.Default für startRow und startCol ist 1
writeData(wb,x=iris,sheet = "Neuer Reiter",startCol = 3,startRow = 4)

#Daten abspeichern
saveWorkbook(wb,"Daten/wb1.xlsx",overwrite = TRUE)
```
]
.panel[.panel-name[Ergebnis]


![openxlsx Bsp 1](img/openxlsx1.png)
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ycphs.github.io/openxlsx/' target="_blank"&gt;
    &lt;img src='https://i2.wp.com/mfatihtuzen.netlify.app/posts/2024-11-04_openxlsx/openxlsx.png?w=578&amp;ssl=1' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## openxlsx: Zellen stylen

.panelset[
.panel[.panel-name[Erklärung]

- Jede Zelle kann mit einem *cell style* versehen werden. Hier können z.B. Hintergrund, Zahlenformat, Farbe usw definiert werden. Eine Übersciht der Möglichkeiten findet ihr [hier](https://rdrr.io/cran/openxlsx/man/createStyle.html)

- Styles könne auf einzelnde Zellen oder auf ganze Zellbereiche angewendet werden. Ausserdem können Styles "gestackt" werden, also gestapelt. So können zusätzliche Style-Features zu einem existierenden Style hinzugefügt werden.

- styles werden mit der `createStyle()` Funktion erstellt und mit der `addStyle()` Funktion auf Zellen angewendet. Wenn ein Style auf eine Zellregion angewendet werden soll, die nicht "quadratisch" ist, muss `gridExpand=TRUE` gesetzt werden.
]
.panel[.panel-name[Code]

```r
library(openxlsx)
# Workbook laden
wb &lt;- loadWorkbook("Daten/wb1.xlsx")
# Styles erstellen
style_1 &lt;- createStyle(fontSize = 18,fontColour = "red")
style_2 &lt;- createStyle(textDecoration = "bold",border = c("top", "bottom", "left", "right"))

# Styles anwenden. Beim Sheet kann auch der Index verwednet werden, aber vorsicht mit Index.
addStyle(wb, sheet = 1, style = style_1,rows = c(4:5),cols = c(3:4),gridExpand = TRUE)
addStyle(wb, sheet = 1, style = style_2,rows = c(5:8),cols = c(3:4),gridExpand = TRUE)
addStyle(wb, sheet = 1, style = style_1,rows = c(7:8),cols = c(3:4),gridExpand = TRUE,stack = TRUE)

#Daten abspeichern
saveWorkbook(wb,"Daten/wb2.xlsx",overwrite = TRUE)
```
]
.panel[.panel-name[Ergebnis]


![openxlsx Bsp 1](img/openxlsx2.png)
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ycphs.github.io/openxlsx/' target="_blank"&gt;
    &lt;img src='https://i2.wp.com/mfatihtuzen.netlify.app/posts/2024-11-04_openxlsx/openxlsx.png?w=578&amp;ssl=1' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## openxlsx: Weitere Funktionen

.panelset[
.panel[.panel-name[Erklärung]

- Weitere nützliche Funktionen sind zum Beispiel das Setzen von Spaltenbreiten und Zeilenhöhen mit `setColWidths()` und `setRowHeights()`

- Mit `cloneWorksheet()` kann ein ganzes Worksheet kopiert werden.

- Es gibt noch unzählige weitere Funktionen. Eine Übersicht findet ihr [hier](https://rdrr.io/cran/openxlsx/man/)
]
.panel[.panel-name[Code]

```r
library(openxlsx)
# Workbook laden
wb &lt;- loadWorkbook("Daten/wb2.xlsx")
# Spaltenbreiten
setColWidths(wb,sheet=1,cols = c(1,2), widths = 3)
setColWidths(wb,sheet=1,cols = 3, widths = 15)

# Zeilenhöhen
setRowHeights(wb,sheet = 1,rows = 9,heights = 8)

#speichern
saveWorkbook(wb,"Daten/wb3.xlsx",overwrite = TRUE)
```
]
.panel[.panel-name[Ergebnis]


![openxlsx Bsp 1](img/openxlsx3.png)
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://ycphs.github.io/openxlsx/' target="_blank"&gt;
    &lt;img src='https://i2.wp.com/mfatihtuzen.netlify.app/posts/2024-11-04_openxlsx/openxlsx.png?w=578&amp;ssl=1' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Hands-On: Daten in Excel schreiben mit openxlsx

Repliziere die Tabelle in `Slides/Daten/openxlsx_table.xlsx`.

Speichere die Datei unter `Slides/Daten/openxlsx_table_DEIN_KÜRZEL.xlsx`.

![openxlsx Aufgabe](img/openxlsx_exercise.png)
<div class="countdown" id="timer_d6c0328e" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## TGexcel

- `TGexcel` basiert auf `openxlsx`, ist aber bereits auf unsere Bedürfnisse abgestimmt

- Das Package enthält bereits Funktionen, die das erstellen und bearbeiten von Internettabellen erleichtern

- Die verwendeten Sytles sind bereits im Package hinterlegt

- Am häufigsten werden wahrscheinlich die Funktionen `create_xlsx_spalte()`,`create_xlsx_zeile()` und `create_xlsx_reiter()` gebraucht. Dies fügen eine Spalte/Zeile/Reiter mit Daten des neuen Jahres an und bedienen sich der Formatierungen aus dem Excelfile des letzten Jahres. Diese Funktionen sind stark vereinfacht. Das bringt sowohl Vorteile als auch Nachteile
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## TGexcel: `create_xlsx_spalte()`

.panelset[
.panel[.panel-name[Erklärung]
         
- Die Funktion hängt für die Daten eines neuen Jahres eine Spalte im Excel File an, passt die Untertitel der Überschrift und ggf. den Namen des Reiters an (z.B. aus 2020-2022 wird 2020-2023)
         
- benötigt wird dafür lediglich den Pfad zur Internettabelle des letzten Jahres als Muster, den Index der Zeile in der die Daten starten (nicht die Kopfzeile) sowie einen Datensatz mit einer Spalte, die als Spaltennamen das neue Jahr trägt.
         
- Die Reihenfolge der Daten muss dabei bereits der in der Exceltabelle entsprechen 
         
- [Doku auf GitHub](https://github.com/ogdtg/TGexcel?tab=readme-ov-file#jahr-als-spalte)
                             
]
  
.panel[.panel-name[Ausgangsdaten]
         

```r
# Dummy Data addiert mit 50
dummy_data &lt;- openxlsx::read.xlsx("Daten/excel_spalte.xlsx", sheet = 1, cols = 7, rows = 3:89) + 50
names(dummy_data) &lt;- "2025"
head(dummy_data, 5)
```

```
##   2025
## 1 2800
## 2  640
## 3  216
## 4  192
## 5   59
```
]
  
.panel[.panel-name[Musterexcel]
         
![openxlsx Bsp 1](img/tgexcel_spalte1.png)
]
  
.panel[.panel-name[Code]
         

```r
library(TGexcel)
# WB des letzten Jahres laden
wb &lt;- loadWorkbook("Daten/excel_spalte.xlsx")

# Daten eintragen. Achtung bei TGexcel muss eine Zuweisung erfolgen
wb &lt;- create_xlsx_spalte(
  xlsx_path = "Daten/excel_spalte.xlsx",
  year = 2025,
  dataStart = 4, # In dieser Zeile starten die Daten
  data = dummy_data
)

# Speichern
save_tg_workbook(wb, "Daten/excel_spalte_new.xlsx", tg_header = FALSE, overwrite = TRUE)
```

```
## File saved without header
```
]
.panel[.panel-name[Ergebnis]
         
![openxlsx Bsp 2](img/tgexcel_spalte2.png)
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## TGexcel: `create_xlsx_zeile()`

.panelset[
.panel[.panel-name[Erklärung]
         
- Die Funktion hängt für die Daten eines neuen Jahres eine Reihe im Excel File an, passt die Untertitel der Überschrift und ggf. den Namen des Reiters an (z.B. aus 2020-2022 wird 2020-2023)
         
- Zu beachten ist, dass als data Argument jeweils ein data.frame übergeben werden muss, bei welchem eine Datenspalte mit dem Namen jahr enthalten sein muss. Diese muss das entsprechende Jahr enthalten. 

- Der Datensatz sollte nur eine Zeile enthalten und die Variablenreihenfolge muss der Reihenfolge im Excel enstprechen
         
- [Doku auf GitHub](https://github.com/ogdtg/TGexcel?tab=readme-ov-file#jahr-als-zeile)
                             
]
  
.panel[.panel-name[Ausgangsdaten]
         

```r
# Dummy Data multipliziert mit 0.96
dummy_data &lt;- openxlsx::read.xlsx("Daten/excel_zeile.xlsx", sheet = 1, cols = 1:4, rows = 8,colNames = FALSE) |&gt; 
  rename(jahr = "X1") |&gt; 
  mutate(jahr = 2024) |&gt; 
  mutate_at(vars(contains("X")),~.x*0.96)
head(dummy_data, 5)
```

```
##   jahr       X2       X3      X4
## 1 2024 29.12077 29.21422 28.9852
```
]
  
.panel[.panel-name[Musterexcel]
         
![openxlsx Bsp 1](img/tgexcel_zeile1.png)
]
  
.panel[.panel-name[Code]
         

```r
library(TGexcel)
# WB des letzten Jahres laden
wb &lt;- loadWorkbook("Daten/excel_zeile.xlsx")

# Daten eintragen. Achtung bei TGexcel muss eine Zuweisung erfolgen
wb &lt;- create_xlsx_zeile(
  xlsx_path = "Daten/excel_zeile.xlsx",
  year = 2024,
  dataStart = 4, # In dieser Zeile starten die Daten
  data = dummy_data
)

# Speichern
save_tg_workbook(wb, "Daten/excel_zeile_new.xlsx", tg_header = FALSE, overwrite = TRUE)
```

```
## File saved without header
```
]
.panel[.panel-name[Ergebnis]
         
![openxlsx Bsp 2](img/tgexcel_zeile2.png)
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## TGexcel: `create_xlsx_reiter()`

.panelset[
.panel[.panel-name[Erklärung]
         
- Die Funktion hängt für die Daten eines neuen Jahres einen Reiter im Excel File an, passt die Untertitel der Überschrift und ggf. den Namen des Reiters an.
         
- Zu beachten ist, dass als data Argument jeweils ein data.frame übergeben werden muss, bei welchem eine Datenspalte mit dem Namen jahr enthalten sein muss. Diese muss das entsprechende Jahr enthalten. 

- Der Datensatz sollte nur eine Zeile enthalten und die Variablenreihenfolge muss der Reihenfolge im Excel enstprechen
         
- [Doku auf GitHub](https://github.com/ogdtg/TGexcel?tab=readme-ov-file#jahr-als-zeile)
                             
]
  
.panel[.panel-name[Ausgangsdaten]
         

```r
# Dummy Data multipliziert mit 0.96
dummy_data &lt;- openxlsx::read.xlsx("Daten/excel_zeile.xlsx", sheet = 1, cols = 1:4, rows = 8,colNames = FALSE) |&gt; 
  rename(jahr = "X1") |&gt; 
  mutate(jahr = 2024) |&gt; 
  mutate_at(vars(contains("X")),~.x*0.96)
head(dummy_data, 5)
```

```
##   jahr       X2       X3      X4
## 1 2024 29.12077 29.21422 28.9852
```
]
  
.panel[.panel-name[Musterexcel]
         
![openxlsx Bsp 1](img/tgexcel_zeile1.png)
]
  
.panel[.panel-name[Code]
         

```r
library(TGexcel)
# WB des letzten Jahres laden
wb &lt;- loadWorkbook("Daten/excel_zeile.xlsx")

# Daten eintragen. Achtung bei TGexcel muss eine Zuweisung erfolgen
wb &lt;- create_xlsx_zeile(
  xlsx_path = "Daten/excel_zeile.xlsx",
  year = 2024,
  dataStart = 4, # In dieser Zeile starten die Daten
  data = dummy_data
)

# Speichern
save_tg_workbook(wb, "Daten/excel_zeile_new.xlsx", tg_header = FALSE, overwrite = TRUE)
```

```
## File saved without header
```
]
.panel[.panel-name[Ergebnis]
         
![openxlsx Bsp 2](img/tgexcel_zeile2.png)
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## TGexcel: Tabelle von Grund auf erstellen

- TGexcel bietet auch die Möglichkeit formatierte Excel Tabellen von Grund auf zu erstellen

- Dies ist vor allem dann nützlich, wenn man sich nicht auf eine Vorlage berufen möchte, z.B. weil sich deren Speicherort verändern könnte, oder aber wenn sich die Struktur der Tabelle leicht verändert und mehrfach erstellt werden muss

- Das Package beinhaltet dafür vier Grundfunktionen:
  - `create_header_style()`: Titel erstellen
  - `create_subheader_style()`: Untertitel erstellen
  - `create_varnames_style()`: Variablennamen erstellen
  - `create_data_style()`: Daten eintragen
  
- Zusätzlich gibt es die Möglichkeit mit `create_nested_header_style()` verschachtelte Variablennamen zu erstellen


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## TGexcel: Tabelle von Grund auf erstellen

.panelset[
.panel[.panel-name[Erklärung]

- in diesem Beispiel wird eine Tabelle mit verschachtelten Variablennamen erstellt

- entscheidend ist dabei das `nesting` Argument. Es definiert wie viele `vars_level2` in eine Variable aus `vars_level1` geschachtelt werden. Der `nesting` Vektor muss daher gleich lang sein wie der `vars_level1`. Der `vars_level2` vektor muss so lang sein, wie die summe des `nesting` Vektor

- Es ist auch möglich mehrfach verschachtelte Variablennamen zu erstellen. Dazu empfiehlt sich ein Blick auf das zweite Beispiel [hier](https://github.com/ogdtg/TGexcel?tab=readme-ov-file#verschachtelt)
]
.panel[.panel-name["Rechenbeispiel"]
 
- Gegeben sind:
  - `vars_level1 = c("BFS-Nr.","Total","männlich","weiblich")`
  - `vars_level2 = c("","","absolut","in %","absolut","in %")`
  - `nesting = c(1,1,2,2)`

- Summe von `nesting` ist `6` und entspricht damit der Länge von `vars_level2`
- Länge von `nesting` ist `4` und entspricht damit der Länge von `vars_level1`

Somit ergibt sich folgendes:
 - `BFS-Nr.` und `Total` erhalten jeweils **ein** untergeordnetes Element, nämlich jeweils `""`, also ein leerer String
 - `männlich` und `weiblich` erhalten jeweils **zwei** untergeordnete Elemente, nämlich jeweils `absolut` und `in %`

]
.panel[.panel-name[Code]

```r
# Workbook neu erstellen
wb &lt;- createWorkbook()
addWorksheet(wb,"Test")
create_header_style(wb = wb, sheet = "Test", ncol = 6, text = "Das ist der Titel")
create_subheader_style(wb = wb, sheet = "Test", ncol = 6, text = "Das ist der Subtitel")
create_nested_header_style(wb = wb,
                           sheet = "Test",
                           nesting = c(1,1,2,2),
                           vars_level1 = c("BFS-Nr.","Total","männlich","weiblich"),
                           vars_level2 = c("","","absolut","in %","absolut","in %"))

#Daten abspeichern
saveWorkbook(wb,"Daten/wb3.xlsx",overwrite = TRUE)
```
]
.panel[.panel-name[Ergebnis]


![openxlsx Bsp 1](img/tgexcel1.png)
]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://github.com/ogdtg/TGexcel' target="_blank"&gt;
    &lt;img src='img/hex-TGexcel.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Hands-On: Daten in Excel schreiben mit TGexcel

Gegeben sind zwei Datensätze

  - `Slides/Daten/gemeinde_order.rds:` enthält alle Gemeinden in der korrekten Reihenfolge wie im Excel
  
  - `Slides/Daten/geburten_24.rds:` enthält Gesamtgeburtenzahlen für das Jahr 2024 nach Gemeinde, Bezirk und für den Gesamtkanton                                                                                                                                                                                      

Gegeben ist ausserdem die Datei `Slides/Daten/2023_Gde_Geb_ab2000.xlsx`                                   
                                                                                                         
Füge die Geburtenzahlen für das Jahr 2024 in die Excel `2023_Gde_Geb_ab2000.xlsx` ein und speichere sie als **`Slides/Daten/2024_Gde_Geb_ab2000_DEIN_KÜRZEL.xlsx`** neu ab         

<div class="countdown" id="timer_0532bcd5" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---























---
----

## Was ist eine API?

- **API** bedeutet:  **Application Programming Interface**  

- Eine API ist wie ein **Kellner** in einem Restaurant:  
  - Du (das Programm) gibst eine **Bestellung** (Anfrage).  
  - Die API bringt deine Bestellung zur **Küche** (Server).  
  - Die Küche liefert die Antwort zurück.

- Sie ermöglicht Programmen, **miteinander zu kommunizieren**.

---
----
## Was ist eine REST API?

- Eine **REST API** nutzt das **HTTP-Protokoll** – wie Webseiten.  

- **REST** steht für: **Representational State Transfer**

- Typische Aufgaben einer REST API:
  - **Daten abrufen**: `GET`-Request 
  - **Daten senden**: `POST`-Request 
  - **Daten aktualisieren** oder **löschen**: `PUT`-Request bzw `DELETE`-Request 
  
- **REST API** können über URLs angesteuert werden. Oft kann man diese auch einfach im Browser eingenben und erhält ein Ergebnis (nützlich zum Ausprobieren)

- Um eine **REST API** anzusteuern wird das `httr` oder das `httr2` Package verwendet.

- Eine **REST API** antwortet in der Regel im JSON Format
---
----
## Die API-Response
.panelset[
.panel[.panel-name[Statuscode]
Der Statuscode gibt an, ob die Anfrage erfolgreich war und liefert Informationen über den Status der Anfrage. Verschiede Stauscodes sind:

- **2xx (Success): Anfrage war erfolgreich** 😄
  - `200 OK`: Anfrage erfolgreich verarbeitet.
  - `201 Created`: Ressource erfolgreich erstellt (bei POST-Anfragen).
- **4xx (Client Error): Problem auf der Seite des Clients** 🤔
  - `400 Bad Request`: Anfrage ist fehlerhaft.
  - `401 Unauthorized`: Fehlende oder ungültige Authentifizierung.
  - `404 Not Found`: Ressource nicht gefunden.
- **5xx (Server Error): Problem auf der Seite des Servers** 😡
  - `500 Internal Server Error`: Unerwarteter Serverfehler.
  - `503 Service Unavailable`: Dienst vorübergehend nicht verfügbar.

]
.panel[.panel-name[Response Body]

Der Body enthält die Daten der Antwort, meistens im JSON- oder XML-Format. Dies ist der Hauptteil der Antwort und enthält je nach API die angeforderten Informationen. Die Daten sind oft kodiert. Die Kodierung händelt aber das `httr2` Package
]
.panel[.panel-name[Headers]
Headers sind zusätzliche Informationen, die mit der Antwort geliefert werden. Sie enthalten Metadaten über die Antwort oder den Server.

**Wichtige Header:**
- `Content-Type:` Typ der Daten im Body (z. B. application/json).
- `Content-Length:` Größe des Response-Bodies.
- `Date:` Zeitpunkt der Antwort.
- `Server:` Informationen über den Server.
- `Authorization:` Informationen zur Authentifizierung (falls relevant).
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## API-Requests mit `httr2`

**Warum `httr2`?**
- Moderner, flexibler und schlanker Ansatz im Vergleich zu `httr`.
- Unterstützt einfache Handhabung von HTTP-Requests, Headern, Body und Authentifizierung.



**Typischer Workflow mit `httr2`:**
  1. Request-Objekt erstellen
  2. Request anpassen (z. B. Header, Query-Parameter)
  3. Request senden und Antwort prüfen
  4. Antwortdaten verarbeiten

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## GET-Request

- `GET`-Requests werden dazu benutzt um Daten abzurufen

- Ohne weitere Spezifikationen führt `httr2` standardmässig ein `GET`-Request aus

- Grundlage eines jeden Request ist die entsprechende URL, der sogenannte **API-Endpoint**. Dieser kann aus der API Dokumentation der entsprchenden Website entnommen werden.

- Eine API-URL besteht in der Regel aus einer base-URL und dem spezifischen Endpoint

**Wichtige Funktionen:**
- `request()`: Erstellt ein Request-Objekt.
- `req_perform()`: Führt die Anfrage aus.
- `resp_body_json()`: Antwort-Body als JSON-Daten einlesen.

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## GET-Request: Beispiel data.tg.ch

.panelset[
.panel[.panel-name[API Console]
[![openxlsx Bsp 1](img/datatg_api.png)](https://data.tg.ch/api/explore/v2.1/console)
]
.panel[.panel-name[Code]

```r
library(httr2)
base_url &lt;- "https://data.tg.ch/api/explore/v2.1"
endpoint &lt;- "/catalog/datasets/sk-stat-56/exports/json"
url &lt;- paste0(base_url,endpoint)

# Request erstellen
response &lt;- request(url) %&gt;% req_perform()

# JSON-Daten extrahieren
data &lt;- response %&gt;% resp_body_json()
```
]
.panel[.panel-name[Response]

```r
response
```

```
## &lt;httr2_response&gt;
## GET https://data.tg.ch/api/explore/v2.1/catalog/datasets/sk-stat-56/exports/json
## Status: 200 OK
## Content-Type: application/json
## Body: In memory (229996 bytes)
```

```r
response$status_code
```

```
## [1] 200
```
]
.panel[.panel-name[Data]

```r
data[[1]]
```

```
## $bfs_nr_gemeinde
## [1] "4461"
## 
## $gemeinde_name
## [1] "Amriswil"
## 
## $bezirk_nr
## [1] "2011"
## 
## $bezirk_name
## [1] "Bezirk Arbon"
## 
## $jahr
## [1] "2024"
## 
## $anzahl_personen
## [1] "14825"
```
]
.panel[.panel-name[Data (aufbereitet)]

```r
data |&gt; bind_rows()
```

```
## # A tibble: 1,440 × 6
##    bfs_nr_gemeinde gemeinde_name     bezirk_nr bezirk_name jahr  anzahl_personen
##    &lt;chr&gt;           &lt;chr&gt;             &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;          
##  1 4461            Amriswil          2011      Bezirk Arb… 2024  14825          
##  2 4406            Dozwil            2011      Bezirk Arb… 2024  725            
##  3 4416            Hefenhofen        2011      Bezirk Arb… 2024  1304           
##  4 4421            Horn              2011      Bezirk Arb… 2024  3148           
##  5 4451            Uttwil            2011      Bezirk Arb… 2024  1909           
##  6 4536            Basadingen-Schla… 2012      Bezirk Fra… 2024  1883           
##  7 4801            Berlingen         2012      Bezirk Fra… 2024  955            
##  8 4561            Felben-Wellhausen 2012      Bezirk Fra… 2024  3213           
##  9 4816            Homburg           2012      Bezirk Fra… 2024  1571           
## 10 4590            Hüttlingen        2012      Bezirk Fra… 2024  903            
## # ℹ 1,430 more rows
```
]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## GET-Request mit Query Paramtern: Beispiel data.tg.ch

.panelset[
.panel[.panel-name[Erklärung]

- Mit Query-Parametern kann die Anfrage verfeinert werden, sodass man genau das erhält was man braucht

- in einer URL kann man Query-Paramter daran erkennen, dass sie nach dem `?` stehen

- auf data.tg.ch kann man zum Beispiel einen SQL-artigen Sysntax anwenden. Die Möglichkeiten von Query Parametern unterscheiden sich aber von API zu API

- Beispiel: `https://data.tg.ch/api/explore/v2.1/catalog/datasets/sk-stat-56/exports/json?select=gemeinde_name,anzahl_personen&amp;where=jahr=date'2021' and gemeinde_name='Frauenfeld'`
]
.panel[.panel-name[Code]

```r
response &lt;- request(url) %&gt;%
  req_url_query(
    select = "gemeinde_name,anzahl_personen", 
    where = "jahr=date'2021' and gemeinde_name='Frauenfeld'"
  ) %&gt;%
  req_perform()

data &lt;- response %&gt;% resp_body_json() |&gt; bind_rows()
```
]
.panel[.panel-name[Response]

```r
response
```

```
## &lt;httr2_response&gt;
## GET https://data.tg.ch/api/explore/v2.1/catalog/datasets/sk-stat-56/exports/json?select=gemeinde_name%2Canzahl_personen&amp;where=jahr%3Ddate%272021%27%20and%20gemeinde_name%3D%27Frauenfeld%27
## Status: 200 OK
## Content-Type: application/json
## Body: In memory (61 bytes)
```

```r
response$status_code
```

```
## [1] 200
```
]
.panel[.panel-name[Data]

```r
data
```

```
## # A tibble: 1 × 2
##   gemeinde_name anzahl_personen
##   &lt;chr&gt;         &lt;chr&gt;          
## 1 Frauenfeld    25816
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## GET-Request mit Authentifizierung: Beispiel dataspot


- Für viele API-Dienste bedarf es einer Authentifizierung

- Dazu gibt es [verschiedene Authentifizierungsmöglichkeiten](https://www.computerweekly.com/de/tipp/API-Sicherheit-Gaengige-Methoden-zur-Authentifizierung):
  - HTTP Basic Authentication
  - Access Tokens
  - OAuth mit OpenID
  - etc.

- Manche dieser Methoden sind sicherer als andere, doch man ist meist nicht frei in der Auswahl, da man nur die Methoden verwenden kann, die auch von Seiten des API-Frameworks implementiert sind

- dataspot verwendet (zumindest in unserer Konfiguration) `HTTP Basic Authentication` mit Passwort und Username. Dies ist zwar am wenigsten "sicher", dafür aber sehr einfach zu verwenden.


---
----
## Einschub: Umgebungsvariablen in R

.panelset[
.panel[.panel-name[Erklärung]

- v.a. Passwörter aber auch API-Keys sollten nicht direkt im Script gespeichert werden

- Umgebungsvariablen helfen dabei, Code und Credentials zu trennen 

- Diese können entweder über `usethis::edit_r_environ()` dauerhaft oder mit `Sys.setenv()` für die Dauer der Session angelegt werden

]
.panel[.panel-name[edit_r_environ()]

- Mit `usethis::edit_r_environ()` öffnet sich das `.Renviron` File. Hier können Umgebungsvariablen direkt eingegeben werden.

- Nach dem Speichern des Files und Neustart der R Session sind die Umgebungsvariablen dauerhaft abrufbar

![renviron file](img/renviron.png)

]
.panel[.panel-name[Sys.setenv()]

- Mit `Sys.setenv()` können Umgebungsvariablen für die Dauer einer Session gesetzt werden

- `Sys.setenv()` überschreibt Umgebungsvariablen aus dem `.Renviron` File für die Dauer der Session.


```r
Sys.setenv(PASSWORT="meinpasswort",
           USER="meinname")
```
]
.panel[.panel-name[Umgebungsvariablen nutzen]

- Egal, wie die Umgebungsvariablen definiert wurden, beziehen kann man sie mit `Sys.getenv()`


```r
Sys.getenv("PASSWORT")
```

```
## [1] "meinpasswort"
```

```r
Sys.getenv("USER")
```

```
## [1] "meinname"
```
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## GET-Request mit Authentifizierung: Beispiel dataspot
.panelset[
.panel[.panel-name[API Doku]

- dataspot besitzt keine API Console zum Testen und nur eine eher rudimentäre Dokumentation

- Mit dieser Doku und viel Herumprobieren kann man dennoch einige Funktionalitäten mit der API darstellen

- [Link zur dataspot-API-Doku](https://dataspot.apps.ktgcpp01.tg.ch/api/dataspot/manual/rest-api)

- Als Beispiel werden wir eine Funktion erstellen, die eine Liste mit allen Referenzdaten erstellt


]
.panel[.panel-name[Code]

```r
library(httr2)
base_url &lt;- "https://dataspot.apps.ktgcpp01.tg.ch/rest/dataspot"
endpoint &lt;- "/schemes/Referenzdaten/enumerations"
url &lt;- paste0(base_url,endpoint)

# Request erstellen
response &lt;- request(url) |&gt; 
  req_auth_basic(username = Sys.getenv("DATASPOT_USER"),password = Sys.getenv("DATASPOT_PW")) |&gt; 
  req_perform()

# JSON-Daten extrahieren
data &lt;- response |&gt; resp_body_json()
```
]
.panel[.panel-name[Response]

```r
response
```

```
## &lt;httr2_response&gt;
## GET https://dataspot.apps.ktgcpp01.tg.ch/rest/dataspot/schemes/Referenzdaten/enumerations
## Status: 200 OK
## Content-Type: application/hal+json
## Body: In memory (384666 bytes)
```

```r
response$status_code
```

```
## [1] 200
```
]
.panel[.panel-name[Data]
![result dataspot](img/req_auth.png)
]
.panel[.panel-name[Data (aufbereitet)]

Daten können dieses Mal nicht so einfach verwendet werden, sondern es bedarf einer etwas komplizierteren Aufbereitung

```r
# dataspotR Package
devtools::load_all("/r-proj/stat/ogd/dataspotR")
```

```
## ℹ Loading dataspotR
```

```r
# Funktion zum aufbereiten aus dem Package
referenzdaten &lt;- prepare_raw_results(data)
referenzdaten
```

```
## # A tibble: 317 × 36
##    `_type`      id    `_version` tenantId publicState modelId href  label status
##    &lt;chr&gt;        &lt;chr&gt;      &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 ReferenceOb… 8a4a…          2 51584d0… DRAFT       13ae8d… /web… Haus… WORKI…
##  2 ReferenceOb… 018c…          6 51584d0… DRAFT       13ae8d… /web… Fünf… WORKI…
##  3 ReferenceOb… f3e0…          1 51584d0… DRAFT       13ae8d… /web… Anga… WORKI…
##  4 ReferenceOb… eb55…          3 51584d0… DRAFT       13ae8d… /web… schw… WORKI…
##  5 ReferenceOb… 9628…          2 51584d0… DRAFT       13ae8d… /web… Beit… WORKI…
##  6 ReferenceOb… 3bc5…          5 51584d0… DRAFT       13ae8d… /web… List… WORKI…
##  7 ReferenceOb… c9eb…          1 51584d0… DRAFT       13ae8d… /web… NOGA… WORKI…
##  8 ReferenceOb… cffe…          4 51584d0… DRAFT       13ae8d… /web… gros… WORKI…
##  9 ReferenceOb… 5ba6…          3 51584d0… DRAFT       13ae8d… /web… Haus… WORKI…
## 10 ReferenceOb… fb7e…          3 51584d0… DRAFT       13ae8d… /web… Haus… WORKI…
## # ℹ 307 more rows
## # ℹ 27 more variables: title &lt;chr&gt;, db &lt;chr&gt;, createdBy &lt;chr&gt;,
## #   dateCreated &lt;dbl&gt;, parentId &lt;chr&gt;, stringType &lt;chr&gt;, description &lt;chr&gt;,
## #   favorite &lt;lgl&gt;, validFrom &lt;dbl&gt;, tags &lt;chr&gt;, self &lt;chr&gt;, derivedFrom &lt;chr&gt;,
## #   inCollection &lt;chr&gt;, literals &lt;chr&gt;, rangeOf &lt;chr&gt;, deployedIn &lt;chr&gt;,
## #   fromMappings &lt;chr&gt;, toMappings &lt;chr&gt;, fromRules &lt;chr&gt;, subordinateOf &lt;chr&gt;,
## #   transformations &lt;chr&gt;, subordinates &lt;chr&gt;, attributedTo &lt;chr&gt;, …
```
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dataspot.apps.ktgcpp01.tg.ch/api/dataspot/manual/rest-api' target="_blank"&gt;
    &lt;img src='img/hex-dataspotR.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## `dataspotR` Package

- Package um die dataspot Rest API zu nutzen

- derzeit nur ein Entwurf, aber durchaus nutzbar

- mit dem Package können ganz einfach alle möglichen Dataspot Elemente bezogen und auch angelegt werden

Das Package ist derzeit noch nicht auf GitHub, kann aber lokal geladen werden mit 


```r
devtools::load_all("/r-proj/stat/ogd/dataspotR")
```

```
## ℹ Loading dataspotR
```
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dataspot.apps.ktgcpp01.tg.ch/api/dataspot/manual/rest-api' target="_blank"&gt;
    &lt;img src='img/hex-dataspotR.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## dataspotR: Referenzdaten beziehen

.panelset[
.panel[.panel-name[Liste beziehen]


```r
# Das, was vorhin gemacht wurde in einer Funktion komprimiert
referenzdaten &lt;- get_referenzdaten_list()
referenzdaten |&gt; 
  select(id,label,title,createdBy)  
```

```
## # A tibble: 317 × 4
##    id                                   label                    title createdBy
##    &lt;chr&gt;                                &lt;chr&gt;                    &lt;chr&gt; &lt;chr&gt;    
##  1 8a4a1ba1-bb81-49ed-9c6c-7dc297ff1556 Haushalte nach Bevölker… Haus… negloff  
##  2 018cca2a-fc08-41ee-8cc0-7cbc5eddbff4 Fünfjahresaltersklasse   Fünf… lparment…
##  3 f3e0c6ca-ac1f-415a-8bb9-9cd6a6416ee8 Angabe zur Anzahl der P… Anga… negloff  
##  4 eb551fb0-2abd-41de-911f-cfd57a214a22 schweizerisch-ausländis… schw… negloff  
##  5 96289c85-4a26-47f4-a671-37fc30c9af1c Beitragsart Listenspital Art … cwalser  
##  6 3bc5ee07-5f08-49f1-871b-ca45cf8f1221 Listenspital TG (mit BU… &lt;NA&gt;  cwalser  
##  7 c9eb8943-7197-42fa-b3a4-597cef7b8f33 NOGA Abschnitt           NOGA… florenz  
##  8 cffe10e3-63c8-45a1-81c5-fa64e2bd7fed grosser Privathaushalt … (pla… negloff  
##  9 5ba690c0-d60c-4bbb-8466-f0f32f1cbf9f Haushalte mit ständiger… Haus… negloff  
## 10 fb7e5a9f-8919-4452-99c5-927979ee8628 Haushalte nach Meldever… Haus… negloff  
## # ℹ 307 more rows
```

]
.panel[.panel-name[Referenzdatenobjekt beziehen]

```r
get_referenzdaten("Thurgauer Gemeinden") |&gt; 
  select(shortText,label,code)
```

```
## # A tibble: 80 × 3
##    shortText  label             code 
##    &lt;chr&gt;      &lt;chr&gt;             &lt;chr&gt;
##  1 Arbon      4401 - Arbon      4401 
##  2 Dozwil     4406 - Dozwil     4406 
##  3 Egnach     4411 - Egnach     4411 
##  4 Hefenhofen 4416 - Hefenhofen 4416 
##  5 Horn       4421 - Horn       4421 
##  6 Kesswil    4426 - Kesswil    4426 
##  7 Roggwil    4431 - Roggwil    4431 
##  8 Romanshorn 4436 - Romanshorn 4436 
##  9 Salmsach   4441 - Salmsach   4441 
## 10 Sommeri    4446 - Sommeri    4446 
## # ℹ 70 more rows
```
]
.panel[.panel-name[Objekte beziehen]

Jedes Objekt auf dataspot besitzt eine ID und kann mit dieser bezogen werden


```r
# Beispiel Sammlung Open Government Data im A-Anlieferungen
get_element_by_id("cb0cc89d-e011-4ee1-8c2c-06a631206926")
```

```
## # A tibble: 1 × 21
##   `_type`    id     `_version` tenantId publicState modelId favorite href  label
##   &lt;chr&gt;      &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;   &lt;lgl&gt;    &lt;chr&gt; &lt;chr&gt;
## 1 Collection cb0cc…          2 51584d0… PUBLIC      f4f20d… TRUE     /web… ogd …
## # ℹ 12 more variables: description &lt;chr&gt;, status &lt;chr&gt;, title &lt;chr&gt;, db &lt;chr&gt;,
## #   createdBy &lt;chr&gt;, dateCreated &lt;dbl&gt;, parentId &lt;chr&gt;, self &lt;chr&gt;,
## #   assets &lt;chr&gt;, collections &lt;chr&gt;, inScheme &lt;chr&gt;, endpoint &lt;chr&gt;
```
]
]
---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## POST-Request

.panelset[
.panel[.panel-name[Erklärung]

- **POST**-Requests werden verwendet, um neue Daten auf einem Server zu erstellen.

- In der Anfrage wird ein **Body** mit den zu sendenden Daten übermittelt (z. B. als JSON).

**Wichtige Funktionen für POST:**
- `req_body_json()`: Legt die Daten im JSON-Format fest.
- `req_perform()`: Führt die Anfrage aus.

]
.panel[.panel-name[Beispiel]

```r
response &lt;- request("https://jsonplaceholder.typicode.com/posts") %&gt;%
  req_body_json(list(
    title = "Neuer Beitrag",
    body = "Dies ist ein Beispieltext",
    userId = 1
  )) %&gt;%
  req_perform()

# Ergebnis ansehen
response %&gt;% resp_body_json()
```

```
## $title
## [1] "Neuer Beitrag"
## 
## $body
## [1] "Dies ist ein Beispieltext"
## 
## $userId
## [1] 1
## 
## $id
## [1] 101
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## PUT-Request

.panelset[
.panel[.panel-name[Erklärung]

- **PUT**-Requests werden verwendet, um Daten auf einem Server zu aktualisieren.

- Dabei wird der gesamte Datensatz ersetzt.

**Wichtige Funktionen für PUT:**
- `req_body_json()`: Legt die zu aktualisierenden Daten fest.
- `req_perform()`: Führt die Anfrage aus.


]
.panel[.panel-name[Beispiel]

```r
response &lt;- request("https://jsonplaceholder.typicode.com/posts/1") %&gt;%
  req_method("PUT") %&gt;%
  req_body_json(list(
    id = 1,
    title = "Aktualisierter Beitrag",
    body = "Der Inhalt wurde aktualisiert",
    userId = 1
  )) %&gt;%
  req_perform()

# Aktualisierte Daten ansehen
response %&gt;% resp_body_json()
```

```
## $id
## [1] 1
## 
## $title
## [1] "Aktualisierter Beitrag"
## 
## $body
## [1] "Der Inhalt wurde aktualisiert"
## 
## $userId
## [1] 1
```
]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## DELETE-Request


.panelset[
.panel[.panel-name[Erklärung]

- **DELETE**-Requests werden verwendet, um Daten auf einem Server zu löschen.

- Es wird keine zusätzliche Datenübertragung (Body) benötigt.

**Wichtige Funktionen für DELETE:**
- `req_method("DELETE")`: Setzt die HTTP-Methode auf DELETE.
- `req_perform()`: Führt die Anfrage aus.


]
.panel[.panel-name[Beispiel]

```r
response &lt;- request("https://jsonplaceholder.typicode.com/posts/1") %&gt;%
  req_method("DELETE") %&gt;%
  req_perform()

# Statuscode prüfen
response$status_code
```

```
## [1] 200
```
]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://httr2.r-lib.org/logo.png' target="_blank"&gt;
    &lt;img src='https://httr2.r-lib.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## Trockenlauf (`req_dry_run()`)

.panelset[
.panel[.panel-name[Erklärung]

- `req_dry_run()` zeigt, wie die Anfrage aussehen würde, ohne sie tatsächlich auszuführen.
- Nützlich, um Anfragen vorab zu prüfen.


]
.panel[.panel-name[Beispiel]

```r
request("https://jsonplaceholder.typicode.com/posts") %&gt;%
  req_method("POST") %&gt;%
  req_body_json(list(
    title = "Test",
    body = "Dies ist ein Test",
    userId = 1
  )) %&gt;%
  req_dry_run()
```

```
## POST /posts HTTP/1.1
## accept: */*
## accept-encoding: deflate, gzip, br, zstd
## content-length: 54
## content-type: application/json
## host: jsonplaceholder.typicode.com
## user-agent: httr2/1.1.2.9000 r-curl/6.4.0 libcurl/7.81.0
## 
## {
##   "title": "Test",
##   "body": "Dies ist ein Test",
##   "userId": 1
## }
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dataspot.apps.ktgcpp01.tg.ch/api/dataspot/manual/rest-api' target="_blank"&gt;
    &lt;img src='img/hex-dataspotR.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Hands-On: Referenzdaten beziehen

Was ist die Entsprechung des Codes `9` für Religionen in der Strukturerhebung? Löse das Problem programmatisch.
Das Ergebnis sollte ein Datensatz mit einer Zeile sein, welcher ID, shortText, code sowie den/die Ersteller/in enthält.

Beachte dass du, wenn du das `dataspotR` benutzen möchtest die Umgebungsvariablen `DATASPOT_USER` und `DATASPOT_PW` initialisieren musst.
---































----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Verbindung herstellen

- um die Verbindung herzustellen muss das `DBI` Package geladen und die `odbc()` Funktion aus dem `odbc` Package verwendet werden

- die benötigten Credentials am Besten wieder als Umgebungsvariablen speichern

- Weitere Infos zur Verbindung auf [Confluence](https://tgweb.tg.ch/display/datastat/R+Workbench)

- Nach der Verbindung können alle Schemata und Tabellen im Reiter `Connecttions` (neben Environment) eingesehen werden

.panelset[
.panel[.panel-name[Intern]


```r
library(DBI)
con &lt;- dbConnect(odbc::odbc(), 
                 Driver="sqlserver", 
                 Server = Sys.getenv("DATABASE_SERVER"), 
                 Port = "1433", 
                 UID = Sys.getenv("LANDING_USER"), 
                 PWD = Sys.getenv("LANDING_PW"), 
                 Database = "landing")
```
]
.panel[.panel-name[Öfeentlich]

```r
library(RSQLite)
con &lt;- dbConnect(RSQLite::SQLite(), "Daten/landing_local.db")
```
]
]

---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Vorhandene Tabellen anzeigen

- Alle vorhandenen Tabellen in einem Schema können mit einem einfachen SQL-Statement abgrufen werden



```r
dbo_tables &lt;- dbListTables(con)
dbo_tables
```

```
## [1] "geres_bestand_2015_2022"  "geres_bestand_2020_12_31"
## [3] "geres_bestand_2021_12_31" "geres_bestand_2022_12_31"
## [5] "geres_bestand_2023_03_31"
```


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## Felder einer Tabelle anzeigen

- Felder einer Tabelle können mit `dbListFields()` abegrufen werden


```r
dbListFields(con, "geres_bestand_2015_2022")
```

```
##  [1] "Stichtag"               "Statistikjahr"          "BFS_Nr"                
##  [4] "NationalitaetAggrID"    "AuslKategorieAggrID"    "StaatsangehoerigkeitID"
##  [7] "KonfessionAggrID"       "GeschlechtID"           "Alter5KlassenID"       
## [10] "AltersKlassenAggrID"    "Anz_StBev"
```

---
----

&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://www.tidyverse.org/' target="_blank"&gt;
    &lt;img src='https://tidyverse.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;

## tidyverse und Datenbanken

.panelset[
.panel[.panel-name[Erklärung]

- mit `tbl` wird ein Pointer zu einer Tabelle erstellt

- die Daten werden dafür noch nicht heruntergeladen

- Auf den Pointer können `tidyverse`-Operationen angewendet werden. Diese werden automatisch in **SQL-Queries** umgewandelt

- Um die Daten dann tatsächlich herunterzuladen kann die `collect()` Funktion verwendet werden

- **SQL-Queries** können mit `show_query()` angezeigt werden
]
.panel[.panel-name[Query erstellen]

```r
query &lt;- tbl(con,"geres_bestand_2015_2022") |&gt; 
  filter(Statistikjahr==2020) |&gt; 
  group_by(StaatsangehoerigkeitID) |&gt; 
  summarise(summe = sum(Anz_StBev,na.rm = TRUE)) |&gt; 
  arrange(desc(summe))

query
```

```
## # Source:     SQL [?? x 2]
## # Database:   sqlite 3.45.0 [/r-proj/stat/workshop/R Workshop DS/Slides/rmd/Daten/landing_local.db]
## # Ordered by: desc(summe)
##    StaatsangehoerigkeitID  summe
##                     &lt;dbl&gt;  &lt;dbl&gt;
##  1                   8100 193400
##  2                   8207   9324
##  3                   8255   3283
##  4                   8218   2907
##  5                   8231   1263
##  6                   8239    685
##  7                   8256    229
##  8                   8230    125
##  9                   8252     76
## 10                   8248     12
## # ℹ more rows
```
]
.panel[.panel-name[Query anzeigen]

```r
query |&gt; show_query()
```

```
## &lt;SQL&gt;
## SELECT `StaatsangehoerigkeitID`, SUM(`Anz_StBev`) AS `summe`
## FROM (
##   SELECT `geres_bestand_2015_2022`.*
##   FROM `geres_bestand_2015_2022`
##   WHERE (`Statistikjahr` = 2020.0)
## ) AS `q01`
## GROUP BY `StaatsangehoerigkeitID`
## ORDER BY `summe` DESC
```

]
.panel[.panel-name[Query ausführen]

```r
data &lt;- query |&gt; collect()
data
```

```
## # A tibble: 12 × 2
##    StaatsangehoerigkeitID  summe
##                     &lt;dbl&gt;  &lt;dbl&gt;
##  1                   8100 193400
##  2                   8207   9324
##  3                   8255   3283
##  4                   8218   2907
##  5                   8231   1263
##  6                   8239    685
##  7                   8256    229
##  8                   8230    125
##  9                   8252     76
## 10                   8248     12
## 11                   8362     11
## 12                   8232     11
```

]
.panel[.panel-name[SQL]

```r
sql_query &lt;- 'SELECT "StaatsangehoerigkeitID", SUM("Anz_StBev") AS "summe"
 FROM (
   SELECT "geres_bestand_2015_2022".*
   FROM "geres_bestand_2015_2022"
   WHERE ("Statistikjahr" = 2020.0)
 ) "q01"
 GROUP BY "StaatsangehoerigkeitID"
 ORDER BY "summe" DESC'
dbGetQuery(con,sql_query)
```

```
##    StaatsangehoerigkeitID  summe
## 1                    8100 193400
## 2                    8207   9324
## 3                    8255   3283
## 4                    8218   2907
## 5                    8231   1263
## 6                    8239    685
## 7                    8256    229
## 8                    8230    125
## 9                    8252     76
## 10                   8248     12
## 11                   8362     11
## 12                   8232     11
```

]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://www.tidyverse.org/' target="_blank"&gt;
    &lt;img src='https://tidyverse.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## tidyverse und Datenbanken

.panelset[
.panel[.panel-name[Erklärung]

- Es ist auch möglich zwei `tbl` Objekte miteinander zu joinen

- Ebenso können `tbl` Objekte mit lokalen Daten gejoined werden. Dazu muss nur der lokale data.frame in einen lazy table umgewandelt werden. Dies wird erreicht indem man innerhalb des joins `copy=TRUE` setzt.

- Diese Option ist allerdings "teuer", da die Ergebnisse temporär in die lokale Session geladen werden. 

]
.panel[.panel-name[Query erstellen]

```r
query &lt;- tbl(con,"geres_bestand_2015_2022") |&gt; 
  filter(Statistikjahr==2020) |&gt; 
  group_by(StaatsangehoerigkeitID) |&gt; 
  summarise(summe = sum(Anz_StBev,na.rm = TRUE)) |&gt; 
  arrange(desc(summe))

query
```

```
## # Source:     SQL [?? x 2]
## # Database:   sqlite 3.45.0 [/r-proj/stat/workshop/R Workshop DS/Slides/rmd/Daten/landing_local.db]
## # Ordered by: desc(summe)
##    StaatsangehoerigkeitID  summe
##                     &lt;dbl&gt;  &lt;dbl&gt;
##  1                   8100 193400
##  2                   8207   9324
##  3                   8255   3283
##  4                   8218   2907
##  5                   8231   1263
##  6                   8239    685
##  7                   8256    229
##  8                   8230    125
##  9                   8252     76
## 10                   8248     12
## # ℹ more rows
```
]
.panel[.panel-name[join lokal]

```r
# Daten aus dataspot
# staaten &lt;- dataspotR::get_referenzdaten("Staaten, Regionen (det/ aggr)") |&gt; 
#   select(shortText,code) |&gt; 
#   mutate_all(as.character)
staaten &lt;- readRDS("Daten/staaten.rds")

# Join und collect
data_join_lokal &lt;- query |&gt; 
  mutate(StaatsangehoerigkeitID = as.character(StaatsangehoerigkeitID)) |&gt; 
  left_join(staaten, join_by("StaatsangehoerigkeitID"=="code"),copy = TRUE) |&gt; 
  collect() |&gt; 
  arrange(desc(summe))
```

```
## Warning: ORDER BY is ignored in subqueries without LIMIT
## ℹ Do you need to move arrange() later in the pipeline or use window_order() instead?
```

]
.panel[.panel-name[join lokal (2)]

```r
data_join_lokal
```

```
## # A tibble: 12 × 3
##    StaatsangehoerigkeitID  summe shortText
##    &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;    
##  1 8100.0                 193400 &lt;NA&gt;     
##  2 8207.0                   9324 &lt;NA&gt;     
##  3 8255.0                   3283 &lt;NA&gt;     
##  4 8218.0                   2907 &lt;NA&gt;     
##  5 8231.0                   1263 &lt;NA&gt;     
##  6 8239.0                    685 &lt;NA&gt;     
##  7 8256.0                    229 &lt;NA&gt;     
##  8 8230.0                    125 &lt;NA&gt;     
##  9 8252.0                     76 &lt;NA&gt;     
## 10 8248.0                     12 &lt;NA&gt;     
## 11 8232.0                     11 &lt;NA&gt;     
## 12 8362.0                     11 &lt;NA&gt;
```

]
]


---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://www.tidyverse.org/' target="_blank"&gt;
    &lt;img src='https://tidyverse.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## tidyverse und Datenbanken

Deutlich ausführlicher wird dieses Thema im Workshop von Cynkra behandelt.

&lt;!-- Ihr findet alle Workshop Unterlagen lokal auf unserer Workbench oder nur die Folien auf [GitHub](https://cynkra.github.io/databases-sg_stat-2024/#1) --&gt;

Ihr findet die Folien auf [GitHub](https://cynkra.github.io/databases-sg_stat-2024/#1).




---
----
&lt;figure class="logo-fig logo-fig-small"&gt;
  &lt;a href='https://dbi.r-dbi.org/' target="_blank"&gt;
    &lt;img src='img/hex-DBI (1).png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
&lt;figure class="logo-fig logo-fig-small2"&gt;
  &lt;a href='https://www.tidyverse.org/' target="_blank"&gt;
    &lt;img src='https://tidyverse.tidyverse.org/logo.png' class='logo'/&gt;
  &lt;/a&gt;
&lt;/figure&gt;
## Hands On: tidyverse und Datenbanken

Errechne den Ausländeranteil pro Gemeinde für die Jahre 2015 bis 2022.

Beachte, dass der finale Datensatz lokal als normaler R data.frame nutzbar sein muss.

**Ergebnis:**


```
## # A tibble: 4 × 3
## # Groups:   Statistikjahr [1]
##   Statistikjahr BFS_Nr auslaenderanteil
##           &lt;dbl&gt;  &lt;dbl&gt;            &lt;dbl&gt;
## 1          2015   4401            11.3 
## 2          2015   4436            12.7 
## 3          2015   4461            15.0 
## 4          2015   4471             4.10
```

<div class="countdown" id="timer_cd1a8728" data-update-every="1" tabindex="0" style="right:0;bottom:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>
---







    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
